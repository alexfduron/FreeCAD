# -*- coding: utf-8 -*-

'''
############################################################################
#                                                                          #
#                                                                          #
#   Copyright (c) 2024                                                     #
#   Original code by:                                                      #
#                       :::====   :::=====  :::====                        #
#                       :::  ===  :::       :::  ===                       #
#                       ========  ======    ===  ===                       #
#                       ===  ===  ===       ===  ===                       #
#                       ===  ===  ===       =======                        #
#                                                                          #
#   This program is free software, you can redistribute it and/or modify   #
#   it under the terms of the GNU Lesser General Public Licence ( LGPL )   #
#   as published by the Free Software Fundation;  either  version  2  of   #
#   the Licence, or (at your option) any later version.                    #
#   for detail see the LICENCE text file.                                  #
#                                                                          #
#   This software is distributed in the hope that  it  will  be  useful,   #
#   but WITHOUT ANY WARRANTY,  without  even  the  implied  warranty  of   #
#   MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   #
#   GNU Library General Public Licence for more details.                   #
#                                                                          #
#   You should have received a copy of the GNU  Library  General  Public   #
#   Licence along with this macro,  if not, write to the  Free  Software   #
#   Foundation Inc., 59 Temple Place, Suite 330,  Boston,  MA 02111-1307   #
#   USA.                                                                   #
#                                                                          #
#                                                                          #
############################################################################
'''

# Macro Begin: C:\Users\OWNER\AppData\Roaming\FreeCAD\Macro\Hoop_1.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
import FreeCAD as App
import FreeCADGui as Gui
import PartDesignGui
import PartDesign
import Sketcher
import Part
import math
from PySide import QtGui
import datetime
import time



#! Estos son las funciones para las Piezas, Cuerpos, Grupos, Bocetos
def Crear_Plano():
	
	# Tomamos el archivo activo
	global Plano
	Plano = App.activeDocument()


def Crear_Grupo(Titulo, Etiqueta = '', Objeto_X = False):
	
	# Validamos los argumentos de la funcion
	if not type(Titulo) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Grupo \n\t {type(Titulo) = }')
	
	if not type(Etiqueta) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Grupo \n\t {type(Etiqueta) = }')
	
	if not str(type(Objeto_X)) in ("<class 'App.Part'>", "<class 'bool'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Part \n\t Funcion = Crear_Grupo \n\t {type(Objeto_X) = }')
	
	
	Grupo_X = Plano.addObject('App::DocumentObjectGroup', Titulo)
	Plano.Tip = Grupo_X
	if Etiqueta == '':
		Grupo_X.Label = Titulo
	else:
		Grupo_X.Label = Etiqueta
	if Objeto_X == False:
		Plano.Tip = Grupo_X
	else:
		Objeto_X.addObject(Grupo_X)
	Plano.recompute()
	return Grupo_X


def Crear_Pieza():
	
	Crear_Plano()
	Pieza_X = Plano.addObject('App::Part','Part_H001')
	Plano.Tip = Pieza_X
	Pieza_X.Label = 'Pieza_H001'
	Plano.recompute()
	return Pieza_X


def Crear_Cuerpo(Titulo, Etiqueta = '', Objeto_X = False):
	
	# Validamos los argumentos de la funcion
	if not type(Titulo) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Cuerpo \n\t {type(Titulo) = }')
		
	if not type(Etiqueta) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Cuerpo \n\t {type(Etiqueta) = }')
		
	if not str(type(Objeto_X)) in ("<class 'App.DocumentObjectGroup'>", "<class 'App.Part'>", "<class 'bool'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Group o Part \n\t Funcion = Crear_Cuerpo \n\t {type(Objeto_X) = }')
	
	
	Cuerpo_X = Plano.addObject('PartDesign::Body', Titulo)
	if Etiqueta == '':
		Cuerpo_X.Label = Titulo
	else:
		Cuerpo_X.Label = Etiqueta
	if Objeto_X == False:
		Plano.Tip = Cuerpo_X
	else:
		Objeto_X.addObject(Cuerpo_X)
	Plano.recompute()
	return Cuerpo_X


def Crear_Boceto(Titulo, Etiqueta = '', Objeto_X = False, Plano_X = ''):
	
	# Validamos los argumentos de la funcion
	if not type(Titulo) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Boceto \n\t {type(Titulo) = }')
		
	if not type(Etiqueta) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Boceto \n\t {type(Etiqueta) = }')
		
	if not str(type(Objeto_X)) in ("<class 'PartDesign.Body'>", "<class 'bool'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Body \n\t Funcion = Crear_Boceto \n\t {type(Objeto_X) = }')
		
	if not type(Plano_X) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Boceto \n\t {type(Plano_X) = }')
	
	
	Boceto_X = Plano.addObject('Sketcher::SketchObject', Titulo)
	Plano.Tip = Boceto_X
	if Plano_X == '':
		Plano_X = 'XY_Plane'
	if Etiqueta == '':
		Boceto_X.Label = Titulo
	else:
		Boceto_X.Label = Etiqueta
	Boceto_X.MapMode = 'FlatFace'
	if Objeto_X == False:
		Plano.Tip = Boceto_X
		Cuerpo_New = Crear_Cuerpo('New_Body', '', Pieza_H1)
		Cuerpo_New.addObject(Boceto_X)
		for k in Cuerpo_New.Origin.OriginFeatures:
			if k.Role == Plano_X:
				XY_Plano = k
		Boceto_X.AttachmentSupport = (XY_Plano, [''])
		del XY_Plano
	else:
		Objeto_X.addObject(Boceto_X)
		for k in Objeto_X.Origin.OriginFeatures:
			if k.Role == Plano_X:
				XY_Plano = k
		Boceto_X.AttachmentSupport = (XY_Plano, [''])
		del XY_Plano
	Plano.recompute()
	return Boceto_X	


def Crear_Variables(Titulo, Etiqueta = '', Objeto_X = False):
	
	# creamos las variables del objeto
	Var_X = Plano.addObject("App::VarSet", Titulo)
	Var_X.Label = Etiqueta
	Objeto_X.addObject(Var_X)
	Var_X.addProperty("App::PropertyLength", "Largo_Total", group="Grupo_2D", doc="Esta propiedad modifica el Largo del Aro")
	Var_X.Largo_Total = "600 mm"
	Var_X.addProperty("App::PropertyLength", "Alto_Total", group="Grupo_2D", doc="Esta propiedad modifica el Alto del Aro")
	Var_X.Alto_Total = "600 mm"
	Var_X.addProperty("App::PropertyLength", "Radio_Principal", group="Grupo_2D", doc="Esta propiedad modifica el Radio interior del Aro")
	Var_X.Radio_Principal = "100 mm"
	Var_X.addProperty("App::PropertyLength", "Radio_Agujero", group="Grupo_2D", doc="Esta propiedad modifica el Radio del Agujero")
	Var_X.Radio_Agujero = "1.5 mm"
	Var_X.addProperty("App::PropertyLength", "Radio_Iman", group="Grupo_2D", doc="Esta propiedad modifica el Radio del Iman")
	Var_X.Radio_Iman = "7 mm"
	Plano.recompute()
	return Var_X


#! Estos son los planos en 2D
def Crear_Contenedor_2D():
	
	### Begin command Std_Part
	global Pieza_H1
	Pieza_H1 = Crear_Pieza()
	
	### Begin command Var_Set
	Variable_H1 = Crear_Variables('VarSet001', 'Variables', Pieza_H1)
	
	### Begin command Std_Group
	global Grupo_LH1
	Grupo_LH1 = Crear_Grupo('Group_LH001', 'Grupo_2D', Pieza_H1)
	
	
	### Begin command PartDesign_Body
	global Cuerpo_LH1
	Cuerpo_LH1 = Crear_Cuerpo('Body_LH001', 'Cuerpo_Layout', Grupo_LH1)
	
	
	### Begin command PartDesign_Sketch
	global Boceto_LVS_C
	Boceto_LVS_C = Crear_Boceto('Sketch_LVS_C001', 'Sketch_LVS_Cuerpo', Cuerpo_LH1)
	global Boceto_LVS_T
	Boceto_LVS_T = Crear_Boceto('Sketch_LVS_T001', 'Sketch_LVS_Tapadera', Cuerpo_LH1)
	global Boceto_LVS_P1
	Boceto_LVS_P1 = Crear_Boceto('Sketch_LVS_P1001', 'Sketch_LVS_Pieza1', Cuerpo_LH1)
	global Boceto_LVS_H_P1
	Boceto_LVS_H_P1 = Crear_Boceto('Sketch_LVS_H_P1001', 'Sketch_LVS_Hoyo_Pieza1', Cuerpo_LH1)
	global Boceto_LVS_P2
	Boceto_LVS_P2 = Crear_Boceto('Sketch_LVS_P2001', 'Sketch_LVS_Pieza2', Cuerpo_LH1)
	global Boceto_LVS_H_P2
	Boceto_LVS_H_P2 = Crear_Boceto('Sketch_LVS_H_P2001', 'Sketch_LVS_Hoyo_Pieza2', Cuerpo_LH1)
	global Boceto_LVS_I
	Boceto_LVS_I = Crear_Boceto('Sketch_LVS_I001', 'Sketch_LVS_Iman', Cuerpo_LH1)
	
	
	
	#! Estos son los planos en 3D
	
	### Begin command PartDesign_Body
	global Cuerpo_H1
	Cuerpo_H1 = Crear_Cuerpo('Body_H001', '', Pieza_H1)
	
	
	### Begin command PartDesign_Sketch
	global Boceto_H1
	Boceto_H1 = Crear_Boceto('Sketch_H001', '', Cuerpo_H1)
	





#! Estos son las funciones para crear Lineas, Arcos, Circulos
def Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'Grupo_001', Guia = False):
	
	# Validamos los argumentos de la funcion
	if not str(type(Pt1)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Linea \n\t {type(Pt1) = }')
	
	if not str(type(Pt2)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Linea \n\t {type(Pt2) = }')
	
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Linea \n\t {type(Boceto_X) = }')
	
	if not type(Restriccion_X) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Linea \n\t {type(Restriccion_X) = }')
	
	if not type(Simetria) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Linea \n\t {type(Simetria) = }')
	
	
	# aqui guardamos el ID de la linea.
	Lista_Linea.append(list(Boceto_X.addGeometry([Part.LineSegment(Pt1, Pt2)], Guia)))
	# aqui creamos la restriccion Horizontal o Vertical de la linea.
	if Restriccion_X != '':
		Boceto_X.addConstraint(Sketcher.Constraint(Restriccion_X, Lista_Linea[-1][0]))
	# aqui redondeamos los valores numericos de los vectores
	Pt1_Temp = App.Vector(round(Pt1.x, 10), round(Pt1.y, 10), round(Pt1.z, 10))
	Pt2_Temp = App.Vector(round(Pt2.x, 10), round(Pt2.y, 10), round(Pt2.z, 10))
	# aqui guardamos el punto inicial: Pt1 => (1) y punto final: Pt2 => (2) de la linea.
	Lista_Linea[-1].append(1)
	Lista_Linea[-1].append(2)
	# aqui guardamos el nombre de la linea.
	Lista_Linea[-1].append('linea')
	# aqui guardamos el Boceto que contiene la linea.
	Lista_Linea[-1].append(Boceto_X.Label)
	# aqui guardamos la magnitud de la linea.
	Pt3 = Pt2 - Pt1
	Lista_Linea[-1].append(round(Pt3.Length, 10))
	# aqui guardamos el punto inicial de la linea.
	Lista_Linea[-1].append(Pt1_Temp)
	# aqui guardamos el punto final de la linea.
	Lista_Linea[-1].append(Pt2_Temp)
	# aqui guardamos el punto centro => N/A.
	Lista_Linea[-1].append(0)
	# aqui guardamos el grupo al que pertenece
	Lista_Linea[-1].append(Grupo_X)
	
	
def Crear_Arco(Pt1, Eje, Radio, Boceto_X, Ang_Ini, Ang_Fin, Simetria = False, Restriccion = False, Grupo_X = 'Grupo_001', Guia = False):
	
	# Validamos los argumentos de la funcion
	if not str(type(Pt1)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Arco \n\t {type(Pt1) = }')
		
	if not str(type(Eje)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Arco \n\t {type(Eje) = }')
		
	if not type(Radio) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Arco \n\t {type(Radio) = }')
	
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Arco \n\t {type(Boceto_X) = }')
		
	if not type(Ang_Ini) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Arco \n\t {type(Ang_Ini) = }')
		
	if not type(Ang_Fin) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Arco \n\t {type(Ang_Fin) = }')
		
	if not type(Simetria) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Arco \n\t {type(Simetria) = }')
	
	
	# aqui guardamos el ID del arco.
	Lista_Linea.append(list(Boceto_X.addGeometry([Part.ArcOfCircle(Part.Circle(Pt1, Eje , Radio), Ang_Ini, Ang_Fin)], Guia)))
	if Restriccion == True:
		# aqui creamos la restriccion Radio del arco.
		Boceto_X.addConstraint(Sketcher.Constraint('Radius', Lista_Linea[-1][0], Radio))
	# aqui creamos los puntos de los extremos del arco con los valores numericos redondeados
	Pt1_Temp = App.Vector(round(Pt1.x + Radio * math.cos(Ang_Ini), 10), round(Pt1.y + Radio * math.sin(Ang_Ini), 10), round(Pt1.z, 10))
	Pt2_Temp = App.Vector(round(Pt1.x + Radio * math.cos(Ang_Fin), 10), round(Pt1.y + Radio * math.sin(Ang_Fin), 10), round(Pt1.z, 10))
	Eje_Temp = App.Vector(round(Pt1.x, 10), round(Pt1.y, 10), round(Pt1.z, 10))
	# aqui guardamos el punto inicial: Pt1_Temp => (1) y punto final: Pt2_Temp => (2) del arco.
	Lista_Linea[-1].append(1)
	Lista_Linea[-1].append(2)
	# aqui guardamos el nombre del arco.
	Lista_Linea[-1].append('arco')
	# aqui guardamos el Boceto que contiene al arco.
	Lista_Linea[-1].append(Boceto_X.Label)
	# aqui guardamos el radio del arco.
	Lista_Linea[-1].append(round(Radio, 10))
	# aqui guardamos el punto inicial del arco.
	Lista_Linea[-1].append(Pt1_Temp)
	# aqui guardamos el punto final del arco.
	Lista_Linea[-1].append(Pt2_Temp)
	# aqui guardamos el punto central del arco.
	Lista_Linea[-1].append(Eje_Temp)
	# aqui guardamos el grupo al que pertenece
	Lista_Linea[-1].append(Grupo_X)
	

def Crear_Circulo(Pt1, Eje, Radio, Boceto_X, Restriccion = True, Grupo_X = 'Grupo_001', Guia = False):
	
	# Validamos los argumentos de la funcion
	if not str(type(Pt1)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Circulo \n\t {type(Pt1) = }')
	
	if not str(type(Eje)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Circulo \n\t {type(Eje) = }')
	
	if not type(Radio) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Circulo \n\t {type(Radio) = }')
	
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Circulo \n\t {type(Boceto_X) = }')
	
	
	# aqui guardamos el ID del circulo.
	Lista_Linea.append(list(Boceto_X.addGeometry([Part.Circle(Pt1, Eje, Radio)], Guia)))
	if Restriccion == True:
		# aqui creamos la restriccion Radio del circulo.
		Boceto_X.addConstraint(Sketcher.Constraint('Radius', Lista_Linea[-1][0], Radio))
	# aqui creamos el punto centro del circulo con los valores numericos redondeados
	Eje_Temp = App.Vector(round(Pt1.x, 10), round(Pt1.y, 10), round(Pt1.z, 10))
	# aqui guardamos el punto inicial => (1) y punto final => (2) del circulo => N/A.
	Lista_Linea[-1].append(0)
	Lista_Linea[-1].append(0)
	# aqui guardamos el nombre del circulo.
	Lista_Linea[-1].append('circulo')
	# aqui guardamos el Boceto que contiene al circulo.
	Lista_Linea[-1].append(Boceto_X.Label)
	# aqui guardamos el radio del circulo.
	Lista_Linea[-1].append(round(Radio, 10))
	# aqui guardamos el punto inicial del circulo => N/A.
	Lista_Linea[-1].append(0)
	# aqui guardamos el punto final del circulo => N/A.
	Lista_Linea[-1].append(0)
	# aqui guardamos el punto central del circulo.
	Lista_Linea[-1].append(Eje_Temp)
	# aqui guardamos el grupo al que pertenece
	Lista_Linea[-1].append(Grupo_X)
	
	
def Validar_Puntos_de_Contacto(Total_Lista):
	
	for j in range(0, Total_Lista)[::-1]:
		Valor_Futuro = (j - 1) % Total_Lista
		
		# aqui validamos que los puntos sean coincidentes
		
		if Lista_Linea[::-1][j][7] == Lista_Linea[::-1][Valor_Futuro][6]:
			
			if Lista_Linea[::-1][j][2] == 2:
				pass
			else:
				Temp = Lista_Linea[::-1][j][1]
				Lista_Linea[::-1][j][1] = Lista_Linea[::-1][j][2]
				Lista_Linea[::-1][j][2] = Temp
				
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				pass
			else:
				Temp = Lista_Linea[::-1][Valor_Futuro][2]
				Lista_Linea[::-1][Valor_Futuro][2] = Lista_Linea[::-1][Valor_Futuro][1]
				Lista_Linea[::-1][Valor_Futuro][1] = Temp
				
		elif Lista_Linea[::-1][j][7] == Lista_Linea[::-1][Valor_Futuro][7]:
			
			if Lista_Linea[::-1][j][2] == 2:
				pass
			else:
				Temp = Lista_Linea[::-1][j][1]
				Lista_Linea[::-1][j][1] = Lista_Linea[::-1][j][2]
				Lista_Linea[::-1][j][2] = Temp
				
			if Lista_Linea[::-1][Valor_Futuro][1] == 2:
				pass
			else:
				Temp = Lista_Linea[::-1][Valor_Futuro][2]
				Lista_Linea[::-1][Valor_Futuro][2] = Lista_Linea[::-1][Valor_Futuro][1]
				Lista_Linea[::-1][Valor_Futuro][1] = Temp
			
		elif Lista_Linea[::-1][j][6] == Lista_Linea[::-1][Valor_Futuro][6]:
			
			if Lista_Linea[::-1][j][2] == 1:
				pass
			else:
				Temp = Lista_Linea[::-1][j][1]
				Lista_Linea[::-1][j][1] = Lista_Linea[::-1][j][2]
				Lista_Linea[::-1][j][2] = Temp
				
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				pass
			else:
				Temp = Lista_Linea[::-1][Valor_Futuro][2]
				Lista_Linea[::-1][Valor_Futuro][2] = Lista_Linea[::-1][Valor_Futuro][1]
				Lista_Linea[::-1][Valor_Futuro][1] = Temp
				
		elif Lista_Linea[::-1][j][6] == Lista_Linea[::-1][Valor_Futuro][7]:
			
			if Lista_Linea[::-1][j][2] == 1:
				pass
			else:
				Temp = Lista_Linea[::-1][j][1]
				Lista_Linea[::-1][j][1] = Lista_Linea[::-1][j][2]
				Lista_Linea[::-1][j][2] = Temp
				
			if Lista_Linea[::-1][Valor_Futuro][1] == 2:
				pass
			else:
				Temp = Lista_Linea[::-1][Valor_Futuro][2]
				Lista_Linea[::-1][Valor_Futuro][2] = Lista_Linea[::-1][Valor_Futuro][1]
				Lista_Linea[::-1][Valor_Futuro][1] = Temp


def Unir_Lineas(Boceto_X, Total_Lista, Objeto_X = ''):
	
	# Validamos los argumentos de la funcion
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Unir_Lineas \n\t {type(Boceto_X) = }')
	
	if not type(Total_Lista) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Unir_Lineas \n\t {type(Total_Lista) = }')
	
	
	# aqui seleccionamos los 'n' ultimos elementos de la lista.
	for j in range(0, Total_Lista)[::-1]:
		# aqui seleccionamos el 'n + 1' elemento de la lista
		Valor_Futuro = (j - 1) % Total_Lista
		
		# aqui analizamos los vectores de dos lineas
		if Lista_Linea[::-1][j][3] == 'linea' and Lista_Linea[::-1][Valor_Futuro][3] == 'linea':
			if Lista_Linea[::-1][j][2] == 1:
				Vector01 = Lista_Linea[::-1][j][6] - Lista_Linea[::-1][j][7]
			else:
				Vector01 = Lista_Linea[::-1][j][7] - Lista_Linea[::-1][j][6]
			if Lista_Linea[::-1][Valor_Futuro][2] == 1:
				Vector02 = Lista_Linea[::-1][Valor_Futuro][6] - Lista_Linea[::-1][Valor_Futuro][7]
			else:
				Vector02 = Lista_Linea[::-1][Valor_Futuro][7] - Lista_Linea[::-1][Valor_Futuro][6]
			# calculamos el producto cruz entre los vectores linea
			Vec3 = Vector01.cross(Vector02)
			# si el producto cruz es igual a cero esto significa 
			# que las dos lineas estan alineados, los vectores son paralelos
			if Objeto_X == '':
				if abs(round(Vec3.Length, 5)) == 0:
					Opcion = 'Vectores Colineales Iguales'
				else:
					Opcion = 'Vectores Coplanares'
			else:
				Opcion = Objeto_X
		
		# aqui analizamos los vectores de una linea y un arco
		if Lista_Linea[::-1][j][3] == 'linea' and Lista_Linea[::-1][Valor_Futuro][3] == 'arco':
			# calculamos el vector de la linea
			if Lista_Linea[::-1][j][2] == 1:
				Vector01 = Lista_Linea[::-1][j][6] - Lista_Linea[::-1][j][7]
			else:
				Vector01 = Lista_Linea[::-1][j][7] - Lista_Linea[::-1][j][6]
			
			# Si el punto inicial esta en la misma ubicacion del angulo inicial 
			# entonces el giro del angulo es en contra de las manecillas del reloj
			# por lo tanto su Normal Esperado es positiva.
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				Normal02_Esperada = App.Vector(0, 0, 1)
			else:
				Normal02_Esperada = App.Vector(0, 0, -1)
			# ahora se calcula el vector centro a extremo inicial del arco
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				Vector02_CE = Lista_Linea[::-1][Valor_Futuro][6] - Lista_Linea[::-1][Valor_Futuro][8]
			else:
				Vector02_CE = Lista_Linea[::-1][Valor_Futuro][7] - Lista_Linea[::-1][Valor_Futuro][8]
			# ahora se calculan los vectores perpendiculares al extremo inicial del arco
			Vector02_P1 = App.Vector(-Vector02_CE.y, Vector02_CE.x, 0)
			Vector02_P2 = App.Vector(Vector02_CE.y, -Vector02_CE.x, 0)
			# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
			Normal02_P1 = Vector02_CE.cross(Vector02_P1)
			Normal02_P2 = Vector02_CE.cross(Vector02_P2)
			# ahora calculamos la Normal Unitaria
			Normal02_P1 = Normal02_P1 / Normal02_P1.Length
			Normal02_P2 = Normal02_P2 / Normal02_P2.Length
			# ahora se compara el signo de la Normal Esperada con
			# el signo de la Normal perpendicular,
			# si ambos son iguales significa que el vector perpendicular el es correcto.
			if Normal02_Esperada == Normal02_P1:
				Vector02_P = Vector02_P1
			elif Normal02_Esperada == Normal02_P2:
				Vector02_P = Vector02_P2
			
			# calculamos el producto cruz entre los vectores linea y tangente del arco
			Vec3 = Vector01.cross(Vector02_P)
			# Ahora sumamos los dos vectores perpendiculares de los arcos
			Vector_T = Vector01 + Vector02_P
			# si el producto cruz es igual a cero
			# significa que los extremos de los arcos estan alineados.
			if abs(round(Vec3.Length, 5)) == 0:
				# si ambos vectores se suman y la magnitud es mayor al vector inicial
				# significa que los vectores estan en el mismo sentido.
				if Vector_T.Length > Vector01.Length:
					Opcion = 'Vectores Colineales Iguales'
				else:
					Opcion = 'Vectores Colineales Opuestos'
			else:
				Opcion = 'Vectores Coplanares'
			
			
		if Lista_Linea[::-1][j][3] == 'arco' and Lista_Linea[::-1][Valor_Futuro][3] == 'linea':
			# Si el punto inicial esta en la misma ubicacion del angulo inicial 
			# entonces el giro del angulo es en contra de las manecillas del reloj
			# por lo tanto su Normal Esperado es positiva.
			if Lista_Linea[::-1][j][1] == 1:
				Normal01_Esperada = App.Vector(0, 0, 1)
			else:
				Normal01_Esperada = App.Vector(0, 0, -1)
			# ahora se calcula el vector centro a extremo final del arco
			if Lista_Linea[::-1][j][2] == 1:
				Vector01_CE = Lista_Linea[::-1][j][6] - Lista_Linea[::-1][j][8]
			else:
				Vector01_CE = Lista_Linea[::-1][j][7] - Lista_Linea[::-1][j][8]
			# ahora se calculan los vectores perpendiculares al extremo final del arco
			Vector01_P1 = App.Vector(-Vector01_CE.y, Vector01_CE.x, 0)
			Vector01_P2 = App.Vector(Vector01_CE.y, -Vector01_CE.x, 0)
			# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
			Normal01_P1 = Vector01_CE.cross(Vector01_P1)
			Normal01_P2 = Vector01_CE.cross(Vector01_P2)
			# ahora calculamos la Normal Unitaria
			Normal01_P1 = Normal01_P1 / Normal01_P1.Length
			Normal01_P2 = Normal01_P2 / Normal01_P2.Length
			# ahora se compara el signo de la Normal Esperada con
			# el signo de la Normal perpendicular,
			# si ambos son iguales significa que el vector perpendicular el es correcto.
			if Normal01_Esperada == Normal01_P1:
				Vector01_P = Vector01_P1
			elif Normal01_Esperada == Normal01_P2:
				Vector01_P = Vector01_P2
			
			# calculamos el vector de la linea
			if Lista_Linea[::-1][Valor_Futuro][2] == 1:
				Vector02 = Lista_Linea[::-1][Valor_Futuro][6] - Lista_Linea[::-1][Valor_Futuro][7]
			else:
				Vector02 = Lista_Linea[::-1][Valor_Futuro][7] - Lista_Linea[::-1][Valor_Futuro][6]
			
			# calculamos el producto cruz entre los vectores tangente del arco y linea
			Vec3 = Vector01_P.cross(Vector02)
			# Ahora sumamos los dos vectores perpendiculares de los arcos
			Vector_T = Vector01_P + Vector02
			# si el producto cruz es igual a cero
			# significa que los extremos de los arcos estan alineados.
			if abs(round(Vec3.Length, 5)) == 0:
				# si ambos vectores se suman y la magnitud es mayor al vector inicial
				# significa que los vectores estan en el mismo sentido.
				if Vector_T.Length > Vector01_P.Length:
					Opcion = 'Vectores Colineales Iguales'
				else:
					Opcion = 'Vectores Colineales Opuestos'
			else:
				Opcion = 'Vectores Coplanares'
		
		
		# aqui analizamos los vectores de dos arcos
		if Lista_Linea[::-1][j][3] == 'arco' and Lista_Linea[::-1][Valor_Futuro][3] == 'arco':
			# Si el punto inicial esta en la misma ubicacion del angulo inicial 
			# entonces el giro del angulo es en contra de las manecillas del reloj
			# por lo tanto su Normal Esperado es positiva.
			if Lista_Linea[::-1][j][1] == 1:
				Normal01_Esperada = App.Vector(0, 0, 1)
			else:
				Normal01_Esperada = App.Vector(0, 0, -1)
			# ahora se calcula el vector centro a extremo final del arco
			if Lista_Linea[::-1][j][2] == 1:
				Vector01_CE = Lista_Linea[::-1][j][6] - Lista_Linea[::-1][j][8]
			else:
				Vector01_CE = Lista_Linea[::-1][j][7] - Lista_Linea[::-1][j][8]
			# ahora se calculan los vectores perpendiculares al extremo final del arco
			Vector01_P1 = App.Vector(-Vector01_CE.y, Vector01_CE.x, 0)
			Vector01_P2 = App.Vector(Vector01_CE.y, -Vector01_CE.x, 0)
			# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
			Normal01_P1 = Vector01_CE.cross(Vector01_P1)
			Normal01_P2 = Vector01_CE.cross(Vector01_P2)
			# ahora calculamos la Normal Unitaria
			Normal01_P1 = Normal01_P1 / Normal01_P1.Length
			Normal01_P2 = Normal01_P2 / Normal01_P2.Length
			# ahora se compara el signo de la Normal Esperada con
			# el signo de la Normal perpendicular,
			# si ambos son iguales significa que el vector perpendicular el es correcto.
			if Normal01_Esperada == Normal01_P1:
				Vector01_P = Vector01_P1
			elif Normal01_Esperada == Normal01_P2:
				Vector01_P = Vector01_P2
			
			# Si el punto inicial esta en la misma ubicacion del angulo inicial 
			# entonces el giro del angulo es en contra de las manecillas del reloj
			# por lo tanto su Normal Esperado es positiva.
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				Normal02_Esperada = App.Vector(0, 0, 1)
			else:
				Normal02_Esperada = App.Vector(0, 0, -1)
			# ahora se calcula el vector centro a extremo inicial del arco
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				Vector02_CE = Lista_Linea[::-1][Valor_Futuro][6] - Lista_Linea[::-1][Valor_Futuro][8]
			else:
				Vector02_CE = Lista_Linea[::-1][Valor_Futuro][7] - Lista_Linea[::-1][Valor_Futuro][8]
			# ahora se calculan los vectores perpendiculares al extremo inicial del arco
			Vector02_P1 = App.Vector(-Vector02_CE.y, Vector02_CE.x, 0)
			Vector02_P2 = App.Vector(Vector02_CE.y, -Vector02_CE.x, 0)
			# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
			Normal02_P1 = Vector02_CE.cross(Vector02_P1)
			Normal02_P2 = Vector02_CE.cross(Vector02_P2)
			# ahora calculamos la Normal Unitaria
			Normal02_P1 = Normal02_P1 / Normal02_P1.Length
			Normal02_P2 = Normal02_P2 / Normal02_P2.Length
			# ahora se compara el signo de la Normal Esperada con
			# el signo de la Normal perpendicular,
			# si ambos son iguales significa que el vector perpendicular el es correcto.
			if Normal02_Esperada == Normal02_P1:
				Vector02_P = Vector02_P1
			elif Normal02_Esperada == Normal02_P2:
				Vector02_P = Vector02_P2
				
			# calculamos el producto cruz entre los vectores centro de cada arco
			Vec3 = Vector01_CE.cross(Vector02_CE)
			# Ahora sumamos los dos vectores perpendiculares de los arcos
			Vector_T = Vector01_P + Vector02_P
			# si el producto cruz es igual a cero
			# significa que los extremos de los arcos estan alineados.
			if abs(round(Vec3.Length, 5)) == 0:
				# si ambos vectores se suman y la magnitud es mayor al vector inicial
				# significa que los vectores estan en el mismo sentido.
				if Vector_T.Length > Vector01_P.Length:
					Opcion = 'Vectores Colineales Iguales'
				else:
					Opcion = 'Vectores Colineales Opuestos'
			else:
				Opcion = 'Vectores Coplanares'
			
		if Opcion == Objeto_X:
			pass
		else:
			if Opcion == 'Vectores Colineales Iguales':
				Boceto_X.addConstraint(Sketcher.Constraint('Tangent', Lista_Linea[::-1][j][0], Lista_Linea[::-1][j][2], Lista_Linea[::-1][Valor_Futuro][0], Lista_Linea[::-1][Valor_Futuro][1]))
			if Opcion == 'Vectores Coplanares' or Opcion == 'Vectores Colineales Opuestos':
				Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[::-1][j][0], Lista_Linea[::-1][j][2], Lista_Linea[::-1][Valor_Futuro][0], Lista_Linea[::-1][Valor_Futuro][1]))
	
	Plano.recompute()
	

def Bloquear_Lineas(Boceto_X, Total_Lista):
	
	# Validamos los argumentos de la funcion
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Bloquear_Lineas \n\t {type(Boceto_X) = }')
	
	if not type(Total_Lista) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Bloquear_Lineas \n\t {type(Total_Lista) = }')
	
	
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'linea':
			Boceto_X.addConstraint(Sketcher.Constraint('Block', Lista_Linea[::-1][j][0]))
	
	Plano.recompute()


def Bloquear_Arcos(Boceto_X, Total_Lista):
	
	# Validamos los argumentos de la funcion
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Bloquear_Arcos \n\t {type(Boceto_X) = }')
	
	if not type(Total_Lista) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Bloquear_Arcos \n\t {type(Total_Lista) = }')
	
	
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'arco':
			Boceto_X.addConstraint(Sketcher.Constraint('Block', Lista_Linea[::-1][j][0]))
			
	Plano.recompute()


def Bloquear_Circulos(Boceto_X, Total_Lista):
	
	# Validamos los argumentos de la funcion
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Bloquear_Circulos \n\t {type(Boceto_X) = }')
	
	if not type(Total_Lista) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Bloquear_Circulos \n\t {type(Total_Lista) = }')
	
	
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'circulo':
			Boceto_X.addConstraint(Sketcher.Constraint('Block', Lista_Linea[::-1][j][0]))
			
	Plano.recompute()


def Fijar_Circulo_Origen(Pt1, Boceto_X, Index_Obj):
	
	# Validamos los argumentos de la funcion
	if not str(type(Pt1)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Fijar_Circulo_Origen \n\t {type(Pt1) = }')
		
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Fijar_Circulo_Origen \n\t {type(Boceto_X) = }')
		
	if not type(Indx_Obj) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Fijar_Circulo_Origen \n\t {type(Index_Obj) = }')
	
	
	if list(Pt1)[0] >= 0:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', -1,1,Index_Obj,3, abs(list(Pt1)[0])))
	else:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', Index_Obj,3,-1,1, abs(list(Pt1)[0])))
	if list(Pt1)[1] >= 0:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceY', -1,1,Index_Obj,3, abs(list(Pt1)[1])))
	else:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceY', Index_Obj,3,-1,1, abs(list(Pt1)[1])))
		
	Plano.recompute()


def Restriccion_Ortogonal_Linea(Lista_X, Boceto_X, All = True):
	
	Lista_ID = []
	
	for j in range(0, len(Lista_X))[::-1]:
		if Lista_Linea[::-1][j][3] == 'linea':
			Lista_ID.append([Lista_X[::-1][j][1], Lista_Linea[::-1][j][0]])
	
	if All == True:
		for k in range(0, len(Lista_ID)):
			Boceto_X.addConstraint(Sketcher.Constraint(Lista_ID[k][0], Lista_ID[k][1]))
	else:
		for k in range(1, len(Lista_ID)):
			Boceto_X.addConstraint(Sketcher.Constraint(Lista_ID[k][0], Lista_ID[k][1]))
			
	Plano.recompute()
			
			
def Restriccion_Igual_Arco(Lista_X, Boceto_X, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral'):
	
	Arco_ID = []
	Restriccion_ID = []
	
	for j in range(0, len(Lista_X))[::-1]:
		if Lista_Linea[::-1][j][3] == Obj_X:
			Arco_ID.append(Lista_Linea[::-1][j][0])
			if len(Arco_ID) == 1:
				if Restriccion == True:
					Restriccion_ID.append(Boceto_X.addConstraint(Sketcher.Constraint('Radius', Arco_ID[0], Lista_Linea[::-1][j][5])))
					if Titulo == 'Radio_Pral':
						Boceto_X.renameConstraint(Restriccion_ID[-1], Titulo)
						Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
						Boceto_X.setExpression('.Constraints.Radio_Pral', u'VarSet001.Radio_Principal < 35 ? 35 : (VarSet001.Radio_Principal > 100 ? 100 : VarSet001.Radio_Principal)')
						
						Lista_Restriccion.append(list(Restriccion_ID))
						Lista_Restriccion[-1].append('Radius')
						Lista_Restriccion[-1].append(Arco_ID[0])
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append(Lista_Linea[::-1][j][5])
						Lista_Restriccion[-1].append(Titulo)
						Lista_Restriccion[-1].append(Lista_Linea[::-1][j][9])
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append(Boceto_X.Label)
						
					else:
						Titulo_Temp = Titulo + '_' + str(1).zfill(2) + '_' + Boceto_X.Label.split('_', 1)[1]
						Validar = True
						
						for j in range(0, len(Lista_Restriccion)):
							Validar = False
							for k in range(0, len(Lista_Restriccion)):
								if Lista_Restriccion[k][7] == Titulo_Temp and Lista_Restriccion[k][10] == Boceto_X.Label:
									Validar = True
									break
							if Validar == True:
								Titulo_Temp4 = int(Titulo_Temp.split('_')[1]) + 1
								Titulo_Temp3 = str(Titulo_Temp4).zfill(2)
								Titulo_Temp = Titulo + '_' + Titulo_Temp3 + '_' + Boceto_X.Label.split('_', 1)[1]
							else:
								break
						Boceto_X.renameConstraint(Restriccion_ID[-1], Titulo_Temp)
						Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
						if Titulo == 'Iman':
							Boceto_X.setExpression('.Constraints.' + Titulo_Temp, u'VarSet001.Radio_Iman > 7 ? 7 : (VarSet001.Radio_Iman < 3 ? 3 : VarSet001.Radio_Iman)')
						elif Titulo == 'Hoyo':
							Boceto_X.setExpression('.Constraints.' + Titulo_Temp, u'VarSet001.Radio_Agujero > 3 ? 3 : (VarSet001.Radio_Agujero < 1 ? 1 : VarSet001.Radio_Agujero)')
						else:
							pass
						
						Lista_Restriccion.append(list(Restriccion_ID))
						Lista_Restriccion[-1].append('Radius')
						Lista_Restriccion[-1].append(Arco_ID[0])
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append(Lista_Linea[::-1][j][5])
						Lista_Restriccion[-1].append(Titulo_Temp)
						Lista_Restriccion[-1].append(Lista_Linea[::-1][j][9])
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append(Boceto_X.Label)
						
					
					
			elif len(Arco_ID) == 2:
				Boceto_X.addConstraint(Sketcher.Constraint('Equal', Arco_ID[0], Arco_ID[1]))
				Arco_ID = [Arco_ID[1]]
				
	Plano.recompute()
				
				
def Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Valor_X, Desfase = False):
	
	Linea01_ID = []
	Linea02_ID = []
	Restriccion_ID = []
	
	for j in range(0, len(Lista_X))[::-1]:
		if Lista_X[::-1][j][0] == 'linea' and Lista_X[::-1][j][1] == 'Vertical':
			Linea01_ID.append(Lista_Linea[::-1][j][0])
			if Desfase == True:
				Linea02_ID.append(Lista_Linea[::-1][j + len(Lista_X)][0])
			if len(Linea01_ID) == 2:
				if Desfase == False:
					Restriccion_ID.append(Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', Linea01_ID[1], 2, Linea01_ID[0], 1, Valor_X)))
					Boceto_X.renameConstraint(Restriccion_ID[-1], u'Largo_Total')
					Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
					Boceto_X.setExpression('.Constraints.Largo_Total', u'VarSet001.Largo_Total < 50 ? 50 : (VarSet001.Largo_Total > 800 ? 800 : VarSet001.Largo_Total)')
					
					Lista_Restriccion.append(list(Restriccion_ID))
					Lista_Restriccion[-1].append('DistanceX')
					Lista_Restriccion[-1].append(Linea01_ID[1])
					Lista_Restriccion[-1].append(2)
					Lista_Restriccion[-1].append(Linea01_ID[0])
					Lista_Restriccion[-1].append(1)
					Lista_Restriccion[-1].append(Valor_X)
					Lista_Restriccion[-1].append('Largo_Total')
					Lista_Restriccion[-1].append(Lista_Linea[::-1][j][9])
					Lista_Restriccion[-1].append(Lista_Linea[::-1][j][9])
					Lista_Restriccion[-1].append(Boceto_X.Label)
					
				else:
					Restriccion_ID.append(Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', Linea02_ID[0], 1, Linea01_ID[0], 1, Valor_X)))
					Boceto_X.renameConstraint(Restriccion_ID[-1], u'Desfase' + str(Restriccion_ID[-1] + 1).zfill(2))
					Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
					
					Lista_Restriccion.append(list(Restriccion_ID))
					Lista_Restriccion[-1].append('DistanceX')
					Lista_Restriccion[-1].append(Linea02_ID[0])
					Lista_Restriccion[-1].append(1)
					Lista_Restriccion[-1].append(Linea01_ID[0])
					Lista_Restriccion[-1].append(1)
					Lista_Restriccion[-1].append(Valor_X)
					Lista_Restriccion[-1].append('Desfase' + str(Restriccion_ID[-1] + 1).zfill(2))
					Lista_Restriccion[-1].append(Lista_Linea[::-1][j + len(Lista_X)][9])
					Lista_Restriccion[-1].append(Lista_Linea[::-1][j][9])
					Lista_Restriccion[-1].append(Boceto_X.Label)
					
	Plano.recompute()
					
				
def Restriccion_DistanciaY_linea(Lista_X, Boceto_X, Valor_X):
	
	Linea_ID = []
	Restriccion_ID = []
	
	for j in range(0, len(Lista_X))[::-1]:
		if Lista_X[::-1][j][0] == 'linea' and Lista_X[::-1][j][1] == 'Horizontal':
			Linea_ID.append(Lista_Linea[::-1][j][0])
			if len(Linea_ID) == 2:
				Restriccion_ID.append(Boceto_X.addConstraint(Sketcher.Constraint('DistanceY', Linea_ID[1], 2, Linea_ID[0], 1, Valor_X)))
				Boceto_X.renameConstraint(Restriccion_ID[-1], u'Alto_Total')
				Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
				Boceto_X.setExpression('.Constraints.Alto_Total', u'VarSet001.Alto_Total < 50 ? 50 : (VarSet001.Alto_Total > 800 ? 800 : VarSet001.Alto_Total)')
				
				Lista_Restriccion.append(list(Restriccion_ID))
				Lista_Restriccion[-1].append('DistanceY')
				Lista_Restriccion[-1].append(Linea_ID[1])
				Lista_Restriccion[-1].append(2)
				Lista_Restriccion[-1].append(Linea_ID[0])
				Lista_Restriccion[-1].append(1)
				Lista_Restriccion[-1].append(Valor_X)
				Lista_Restriccion[-1].append('Alto_Total')
				Lista_Restriccion[-1].append(Lista_Linea[::-1][j][9])
				Lista_Restriccion[-1].append(Lista_Linea[::-1][j][9])
				Lista_Restriccion[-1].append(Boceto_X.Label)
				
	Plano.recompute()
				
				
def Simetria_Objeto_Eje(Lista_X, Boceto_X, Objeto, Eje = -1, Paso = 1):
	
	'''
	Nota:
		Eje = -1 => es para el eje X
		Eje = -2 => es para el eje Y 
	'''
	
	Objeto_ID = []
	Contador = 0
	
	for j in range(0, len(Lista_X))[::-1]:
		if Lista_Linea[::-1][j][3] == Objeto:
			Contador += 1
			if Contador % Paso == 0:
				Objeto_ID.append(Lista_Linea[::-1][j][0])
	
	Boceto_X.addConstraint(Sketcher.Constraint('Symmetric', Objeto_ID[0], 3, Objeto_ID[1], 3, Eje, 1))
	
	Plano.recompute()
	
	
def Restriccion_Coincidente_Arco(Lista_X, Boceto_X):
	
	Lista01_ID = []
	Lista02_ID = []
	
	for j in range(0, len(Lista_X))[::-1]:
		if Lista_Linea[::-1][j][3] == 'arco':
			Lista01_ID.append(Lista_Linea[::-1][j][0])
			Lista02_ID.append(Lista_Linea[::-1][j + len(Lista_X)][0])
			
	for k in range(0, len(Lista01_ID)):
		Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista01_ID[k], 3, Lista02_ID[k], 3))
		
	Plano.recompute()
	
	
def Mostrar_Ultimo_Grupo(Boceto_X):
	
	# aqui mostramos el ultimo Grupo generado en la Lista_Linea
	Lista_Grupo = []
	if len(Lista_Linea) == 0:
		Grupo_Y = 'Grupo_001'
	else:
		for k in range(0, len(Lista_Linea)):
			if Lista_Linea[k][4] == Boceto_X.Label:
				Lista_Grupo.append(Lista_Linea[k][9])
		if len(Lista_Grupo) == 0:
			Grupo_Y = 'Grupo_001'
		else:
			Lista_Grupo = sorted(list(set(Lista_Grupo)))
			Grupo_Y = Lista_Grupo[-1]
			
	return Grupo_Y
	
	
def Actualizar_Grupo(Boceto_X):
	
	# aqui actualizamos el Grupo al que pertenencen los objetos
	Lista_Grupo = []
	if len(Lista_Linea) == 0:
		Grupo_Y = 'Grupo_001'
	else:
		for k in range(0, len(Lista_Linea)):
			if Lista_Linea[k][4] == Boceto_X.Label:
				Lista_Grupo.append(Lista_Linea[k][9])
		if len(Lista_Grupo) == 0:
			Grupo_Y = 'Grupo_001'
		else:		
			Lista_Grupo = sorted(list(set(Lista_Grupo)))
			Grupo_Y = 'Grupo_' + str(int(Lista_Grupo[-1].split('_')[1]) + 1).zfill(3)
			
	return Grupo_Y
	
	
def Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
	
	if Indice_X % 2 == 0:
		Eje_Temp = -2
		Restriccion_Temp = 'DistanceX'
	else:
		Eje_Temp = -1
		Restriccion_Temp = 'DistanceY'
	
	#Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'Grupo_001', Guia = False):
	Crear_Linea(Lista_Circulo[Indice_X][1][0][6], Lista_Circulo[Indice_X][1][1][6], Boceto_X, Grupo_X = Grupo_Temp, Guia = True)
	
	Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Circulo[Indice_X][1][0][0], 1, Lista_Linea[-1][0], 1))
	Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Circulo[Indice_X][1][1][0], 1, Lista_Linea[-1][0], 2))
	
	Plano.recompute()
	
	#Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'Grupo_001', Guia = False):
	Crear_Linea(Lista_Circulo[Indice_X][1][0][7], Lista_Circulo[Indice_X][1][1][7], Boceto_X, Grupo_X = Grupo_Temp, Guia = True)
	
	Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Circulo[Indice_X][1][0][0], 2, Lista_Linea[-1][0], 1))
	Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Circulo[Indice_X][1][1][0], 2, Lista_Linea[-1][0], 2))
	
	Plano.recompute()
	
	#Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'Grupo_001', Guia = False):
	Crear_Linea(Lista_Circulo[Indice_X][1][0][6], Lista_Circulo[Indice_X][1][0][7], Boceto_X, Grupo_X = Grupo_Temp, Guia = True)
	
	Boceto_X.addConstraint(Sketcher.Constraint('Symmetric', Lista_Circulo[Indice_X][1][0][0], 1, Lista_Circulo[Indice_X][1][1][0], 1, Lista_Linea[-1][0], 1))
	Boceto_X.addConstraint(Sketcher.Constraint('Symmetric', Lista_Circulo[Indice_X][1][0][0], 2, Lista_Circulo[Indice_X][1][1][0], 2, Lista_Linea[-1][0], 2))
	
	Plano.recompute()
	
	for y in range(0, len(Lista_Circulo[Indice_X][2])):
		Boceto_X.addConstraint(Sketcher.Constraint('PointOnObject', Lista_Circulo[Indice_X][2][y][0], 3, Lista_Linea[-1][0]))
	
	for w in range(0, len(Lista_Circulo[Indice_X][2])):
		Boceto_X.addConstraint(Sketcher.Constraint(Restriccion_Temp, Eje_Temp, 1, Lista_Circulo[Indice_X][2][w][0], 3, list(Lista_Circulo[Indice_X][2][w][8])[Indice_X % 2]))
	
	Plano.recompute()
	
	
def Fijar_Agujeros_a_Cuerpo(Lista01_X, Lista02_X, Boceto_X, Grupo_X, Grupo_Y):
	
	Lista01_Y = []
	Lista02_Y = []
	Lista_Circulo = []
	
	# Mostrar_Ultimo_Grupo(Boceto_X):
	Grupo_Z = Mostrar_Ultimo_Grupo(Boceto_X)
	
	# Actualizar_Grupo(Boceto_X):
	Grupo_Temp = Actualizar_Grupo(Boceto_X)
	
	for k in range(0, len(Lista01_X)):
		Lista01_Y.append([Lista01_X[k][0], Lista01_X[k][1]])
	
	for k in range(0, len(Lista01_X)):
		if [Lista02_X[k][0], Lista02_X[k][1], Lista02_X[k][2]] in Lista02_Y:
			pass
		else:
			Lista02_Y.append([Lista02_X[k][0], Lista02_X[k][1], Lista02_X[k][2]])
	
	for j in range(0, len(Lista02_Y)):
		Lista_Circulo.append([])
		Lista_Circulo[j].append(Lista02_Y[j])
		Lista_Circulo[j].append([])
		Lista_Circulo[j].append([])
		
		Lista01_G = []
		Lista02_G = []
		
		for k in range(0, len(Lista_Linea)):
			if Lista_Linea[k][9] == Grupo_X:
				Lista01_G.append(Lista_Linea[k])
		
		for k in range(0, len(Lista_Linea)):
			if Lista_Linea[k][9] == Grupo_Y:
				Lista02_G.append(Lista_Linea[k])
		
		for t in range(0, len(Lista01_Y)):
			if Lista01_Y[t][0] == 'linea' and 2 * j == t:
				Lista_Circulo[j][1].append(Lista01_G[t])
				Lista_Circulo[j][1].append(Lista02_G[t])
		
		
		if j == 0:
			for f in range(0, len(Lista_Linea)):
				if Lista_Linea[f][3] == 'circulo' and Lista_Linea[f][9] == Grupo_Z and Lista_Linea[f][4] == Boceto_X.Label:
					if Lista02_Y[j][1] * Lista02_Y[j][2] == list(Lista_Linea[f][8])[1]:
						Lista_Circulo[j][2].append(Lista_Linea[f])
			
			# Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
			Restriccion_Agujeros_a_Cuerpo(j, Lista_Circulo, Boceto_X, Grupo_Temp)
		
		
		if j == 1:
			for f in range(0, len(Lista_Linea)):
				if Lista_Linea[f][3] == 'circulo' and Lista_Linea[f][9] == Grupo_Z and Lista_Linea[f][4] == Boceto_X.Label:
					if Lista02_Y[j][1] * Lista02_Y[j][2] == list(Lista_Linea[f][8])[0]:
						Lista_Circulo[j][2].append(Lista_Linea[f])
						
			# Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
			Restriccion_Agujeros_a_Cuerpo(j, Lista_Circulo, Boceto_X, Grupo_Temp)
		
		
		if j == 2:
			for f in range(0, len(Lista_Linea)):
				if Lista_Linea[f][3] == 'circulo' and Lista_Linea[f][9] == Grupo_Z and Lista_Linea[f][4] == Boceto_X.Label:
					if Lista02_Y[j][1] * Lista02_Y[j][2] == list(Lista_Linea[f][8])[1]:
						Lista_Circulo[j][2].append(Lista_Linea[f])
						
			# Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
			Restriccion_Agujeros_a_Cuerpo(j, Lista_Circulo, Boceto_X, Grupo_Temp)
		
		
		if j == 3:
			for f in range(0, len(Lista_Linea)):
				if Lista_Linea[f][3] == 'circulo' and Lista_Linea[f][9] == Grupo_Z and Lista_Linea[f][4] == Boceto_X.Label:
					if Lista02_Y[j][1] * Lista02_Y[j][2] == list(Lista_Linea[f][8])[0]:
						Lista_Circulo[j][2].append(Lista_Linea[f])
			
			# Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
			Restriccion_Agujeros_a_Cuerpo(j, Lista_Circulo, Boceto_X, Grupo_Temp)
	
	Plano.recompute()
	
	
	
def Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	
	# Validamos los argumentos de la funcion
	if not type(Lista_X) is list:
		raise TypeError(f'\n\n\t Mensaje = No es Lista \n\t Funcion = Crear_Contorno \n\t {type(Lista_X) = }')
		
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Contorno \n\t {type(Boceto_X) = }')
		
	if not type(Simetria) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Contorno \n\t {type(Simetria) = }')
		
	if not type(Espejo) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Contorno \n\t {type(Espejo) = }')
		
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Contorno \n\t {type(Largo_Total) = }')
		
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Contorno \n\t {type(Alto_Total) = }')
		
	if not type(Desfase) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Contorno \n\t {type(Desfase) = }')
	
		
	# Actualizar_Grupo(Boceto_X):
	Grupo_Y = Actualizar_Grupo(Boceto_X)
	
	
	#Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'Grupo_001', Guia = False):
	#Crear_Arco(Pt1, Eje, Radio, Boceto_X, Ang_Ini, Ang_Fin, Simetria = False, Restriccion = False, Grupo_X = 'Grupo_001', Guia = False):
	for j in range(0, len(Lista_X)):
		if Lista_X[j][0] == 'linea':
			Crear_Linea(App.Vector(Lista_X[j][2], Lista_X[j][3], 0), App.Vector(Lista_X[j][4], Lista_X[j][5], 0), Boceto_X, Grupo_X = Grupo_Y, Guia = Guia_X)
		if Lista_X[j][0] == 'arco':
			Crear_Arco(App.Vector(Lista_X[j][1], Lista_X[j][2], 0), Lista_X[j][3], Lista_X[j][4], Boceto_X, Lista_X[j][5], Lista_X[j][6], Grupo_X = Grupo_Y, Guia = Guia_X)
	
	# Validar_Puntos_de_Contacto(Total_Lista):
	Validar_Puntos_de_Contacto(len(Lista_X))
	
	if Simetria == False and Espejo == False:
		
		if Largo_Total != -1:
			# Restriccion_Ortogonal_Linea(Lista_X, Boceto_X, All = True):
			Restriccion_Ortogonal_Linea(Lista_X, Boceto_X)
		else:
			# Restriccion_Ortogonal_Linea(Lista_X, Boceto_X, All = True):
			Restriccion_Ortogonal_Linea(Lista_X, Boceto_X, False)
		
		# Unir_Lineas(Boceto_X, Total_Lista, Objeto_X = ''):
		Unir_Lineas(Boceto_X, len(Lista_X))
		
		if Largo_Total != -1:
			# Restriccion_Igual_Arco(Lista_X, Boceto_X, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral'):
			Restriccion_Igual_Arco(Lista_X, Boceto_X, 'arco', True, 'Radio_Pral')
		
		if Largo_Total != -1:
			# Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Valor_X, Desfase = False):
			Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Largo_Total)
		
			# Restriccion_DistanciaY_linea(Lista_X, Boceto_X, Valor_X):
			Restriccion_DistanciaY_linea(Lista_X, Boceto_X, Alto_Total)
			
			# Simetria_Objeto_Eje(Lista_X, Boceto_X, Objeto, Eje = -1, Paso = 1):
			Simetria_Objeto_Eje(Lista_X, Boceto_X, 'arco', -1, 2)
			
		if Desfase != -1:
			# Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Valor_X, Desfase = False):
			Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Desfase, True)
			
			# Restriccion_Coincidente_Arco(Lista_X, Boceto_X):
			Restriccion_Coincidente_Arco(Lista_X, Boceto_X)
			
	if Espejo == True:
		# Bloquear_Lineas(Boceto_X, Total_Lista):
		Bloquear_Lineas(Boceto_X, len(Lista_X))
		
		# Unir_Lineas(Boceto_X, Total_Lista, Objeto_X = ''):
		Unir_Lineas(Boceto_X, len(Lista_X))
		
		# Bloquear_Arcos(Boceto_X, Total_Lista):
		Bloquear_Arcos(Boceto_X, len(Lista_X))
		
	Plano.recompute()
	
	
	#Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'Grupo_001', Guia = False):
	#Crear_Arco(Pt1, Eje, Radio, Boceto_X, Ang_Ini, Ang_Fin, Simetria = False, Restriccion = False, Grupo_X = 'Grupo_001', Guia = False):
	if Simetria == True:
		#$ Objeto Simetrico en el centro
		for k in range(0, len(Lista_X)):
			if Lista_X[::-1][k][0] == 'linea':
				Crear_Linea(App.Vector(-Lista_X[::-1][k][2], Lista_X[::-1][k][3], 0), App.Vector(-Lista_X[::-1][k][4], Lista_X[::-1][k][5], 0), Boceto_X, Simetria = True, Grupo_X = Grupo_Y, Guia = Guia_X)
			if Lista_X[::-1][k][0] == 'arco':
				Crear_Arco(App.Vector(-Lista_X[::-1][k][1], Lista_X[::-1][k][2], 0), Lista_X[::-1][k][3], Lista_X[::-1][k][4], Boceto_X, math.radians(180) - Lista_X[::-1][k][6], math.radians(180) - Lista_X[::-1][k][5], True, Grupo_X = Grupo_Y, Guia = Guia_X)
		
		# Validar_Puntos_de_Contacto(Total_Lista):
		Validar_Puntos_de_Contacto(2 * len(Lista_X))
		
	if Espejo == True:
		#$ Objeto Espejo con respecto al Origen
		for k in range(0, len(Lista_X)):
			if Lista_X[k][0] == 'linea':
				Crear_Linea(App.Vector(-Lista_X[k][2], Lista_X[k][3], 0), App.Vector(-Lista_X[k][4], Lista_X[k][5], 0), Boceto_X, Grupo_X = Grupo_Y, Guia = Guia_X)
			if Lista_X[k][0] == 'arco':
				Crear_Arco(App.Vector(-Lista_X[k][1], Lista_X[k][2], 0), Lista_X[k][3], Lista_X[k][4], Boceto_X, math.radians(180) - Lista_X[k][6], math.radians(180) - Lista_X[k][5], Grupo_X = Grupo_Y, Guia = Guia_X)
		
		# Validar_Puntos_de_Contacto(Total_Lista):
		Validar_Puntos_de_Contacto(len(Lista_X))
	
	Plano.recompute()
	
	
	if Simetria == True:
		
		# Bloquear_Lineas(Boceto_X, Total_Lista)
		Bloquear_Lineas(Boceto_X, 2 * len(Lista_X))
		
		# Unir_Lineas(Boceto_X, Total_Lista, Objeto_X = ''):
		Unir_Lineas(Boceto_X, 2 * len(Lista_X), 'arco')
		
		# Bloquear_Arcos(Boceto_X, Total_Lista)
		Bloquear_Arcos(Boceto_X, 2 * len(Lista_X))
		
	if Espejo == True:
		# Bloquear_Lineas(Boceto_X, Total_Lista):
		Bloquear_Lineas(Boceto_X, len(Lista_X))
		
		# Unir_Lineas(Boceto_X, Total_Lista, Objeto_X = ''):
		Unir_Lineas(Boceto_X, len(Lista_X))
		
		# Bloquear_Arcos(Boceto_X, Total_Lista):
		Bloquear_Arcos(Boceto_X, len(Lista_X))
	
	Plano.recompute()


def Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, Separacion = 76, Inicio_Centro = False, Incluir_Arco = False, Grupo_Base = ['', ''], Titulo_X = 'Radio'):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Radio_Pral) = }')
	
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Agujeros \n\t {type(Boceto_X) = }')
	
	if not type(Radio_Agujero) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Radio_Agujero) = }')
		
	if not type(Separacion) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Separacion) = }')
	
	if not type(Inicio_Centro) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Agujeros \n\t {type(Inicio_Centro) = }')
		
	if not type(Incluir_Arco) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Agujeros \n\t {type(Incluir_Arco) = }')
	
	
	# Actualizar_Grupo(Boceto_X):
	Grupo_Y = Actualizar_Grupo(Boceto_X)
		
	
	Separacion = Separacion / 2
	Val_X = (Largo_Total / 2) + 1 + 14 / 2
	Val_Y = (Alto_Total / 2) + 1 + 14 / 2
	Delta_X = (Largo_Total - 2 * Radio_Pral) / 2
	Delta_Y = (Alto_Total - 2 * Radio_Pral) / 2
	Multi_X = math.floor(Delta_X / Separacion)
	Multi_Y = math.floor(Delta_Y / Separacion)
	
	if Multi_X == 0:
		if Inicio_Centro == True:
			DeltaVal_X = [0]
		else:
			DeltaVal_X = [Delta_X]
	elif Multi_X == 1:
		if Inicio_Centro == True:
			DeltaVal_X = [0]
		else:
			DeltaVal_X = [Separacion]
	elif Multi_X == 2:
		if Inicio_Centro == True:
			DeltaVal_X = [0, Separacion * 2]
		else:
			DeltaVal_X = [Separacion]
	else:
		if Inicio_Centro == True:
			Multi_X = math.floor((Delta_X - 2 * Separacion) / (Separacion * 2))
			DeltaVal_X = [0, Separacion * 2]
			Ciclo = Separacion * 2
			for k in range(Multi_X):
				Ciclo += Separacion * 2
				DeltaVal_X.append(Ciclo)
		else:
			Multi_X = math.floor((Delta_X - Separacion) / (Separacion * 2))
			DeltaVal_X = [Separacion]
			Ciclo = Separacion
			for k in range(Multi_X):
				Ciclo += Separacion * 2
				DeltaVal_X.append(Ciclo)
			if math.floor(((Delta_X - Separacion) - Separacion * 2 * Multi_X) / Separacion) >= 1:
				DeltaVal_X.append(Delta_X)
			
	if Multi_Y == 0:
		if Inicio_Centro == True:
			DeltaVal_Y = [0]
		else:
			DeltaVal_Y = [Delta_Y]
	elif Multi_Y == 1:
		if Inicio_Centro == True:
			DeltaVal_Y = [0]
		else:
			DeltaVal_Y = [Separacion]
	elif Multi_Y == 2:
		if Inicio_Centro == True:
			DeltaVal_Y = [0, Separacion * 2]
		else:
			DeltaVal_Y = [Separacion]
	else:
		if Inicio_Centro == True:
			Multi_Y = math.floor((Delta_Y - 2 * Separacion) / (Separacion * 2))
			DeltaVal_Y = [0, Separacion * 2]
			Ciclo = Separacion * 2
			for k in range(Multi_Y):
				Ciclo += Separacion * 2
				DeltaVal_Y.append(Ciclo)
		else:
			Multi_Y = math.floor((Delta_Y - Separacion) / (Separacion * 2))
			DeltaVal_Y = [Separacion]
			Ciclo = Separacion
			for k in range(Multi_Y):
				Ciclo += Separacion * 2
				DeltaVal_Y.append(Ciclo)
			if math.floor(((Delta_Y - Separacion) - Separacion * 2 * Multi_Y) / Separacion) >= 1:
				DeltaVal_Y.append(Delta_Y)
	
	
	# Actualizar_Lista02(Val_X, Val_Y):
	Lista02 = Actualizar_Lista02(Val_X, Val_Y)
	
	# Actualizar_Lineal_Lista03(Lista02, DeltaVal_X, DeltaVal_Y, Radio_Agujero, Inicio_Centro = False):
	Lista03 = Actualizar_Lineal_Lista03(Lista02, DeltaVal_X, DeltaVal_Y, Radio_Agujero, Inicio_Centro)
	
	for k in range(0, len(Lista03)):
		# Crear_Circulo(Pt1, Eje, Radio, Boceto_X, Restriccion = True, Grupo_X = 'Grupo_001', Guia = False):
		Crear_Circulo(Lista03[k][0], Lista03[k][1], Lista03[k][2], Boceto_X, False, Grupo_Y)
	
	# Restriccion_Igual_Arco(Lista_X, Boceto_X, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral'):
	Restriccion_Igual_Arco(Lista03, Boceto_X, Obj_X = 'circulo', Restriccion = True, Titulo = Titulo_X)
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Total, Alto_Total, Radio_Pral)
	
	# Fijar_Agujeros_a_Cuerpo(Lista01_X, Lista02_X, Boceto_X, Grupo_X, Grupo_Y):
	Fijar_Agujeros_a_Cuerpo(Lista01, Lista02, Boceto_X, Grupo_Base[0], Grupo_Base[1])
	
	Plano.recompute()
	
	if Incluir_Arco == True:
		
		Lista03 = []
		
		# Actualizar_Grupo(Boceto_X):
		Grupo_Y = Actualizar_Grupo(Boceto_X)
		
		# Actualizar_Polar_Lista03(Lista02, Delta_X, Delta_Y, Radio_Agujero, Lista03 = []):
		Lista03 = Actualizar_Polar_Lista03(Lista02, Delta_X, Delta_Y, Radio_Agujero, Lista03)
		
		for k in range(0, len(Lista03)):
			# Crear_Circulo(Pt1, Eje, Radio, Boceto_X, Restriccion = True, Grupo_X = 'Grupo_001', Guia = False):
			Crear_Circulo(Lista03[k][0], Lista03[k][1], Lista03[k][2], Boceto_X, False, Grupo_Y)
		
		# Restriccion_Igual_Arco(Lista_X, Boceto_X, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral'):
		Restriccion_Igual_Arco(Lista03, Boceto_X, Obj_X = 'circulo', Restriccion = True, Titulo = Titulo_X)
		
		
	

def Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista01 \n\t {type(Largo_X) = }')
	
	if not type(Alto_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista01 \n\t {type(Alto_X) = }')
		
	if not type(Radio_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista01 \n\t {type(Radio_X) = }')
	
	
	# Contorno circular
	Lista01 = [
		['linea', 'Horizontal', -(Largo_X - 2 * Radio_X) / 2, Alto_X / 2, (Largo_X - 2 * Radio_X) / 2, Alto_X / 2],
		['arco', (Largo_X - 2 * Radio_X) / 2, (Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(0), math.radians(90)],
		['linea', 'Vertical', Largo_X / 2, (Alto_X - 2 * Radio_X) / 2, Largo_X / 2, -(Alto_X - 2 * Radio_X) / 2],
		['arco', (Largo_X - 2 * Radio_X) / 2, -(Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(270), math.radians(360)],
		['linea', 'Horizontal', (Largo_X - 2 * Radio_X) / 2, -Alto_X / 2, -(Largo_X - 2 * Radio_X) / 2, -Alto_X / 2],
		['arco', -(Largo_X - 2 * Radio_X) / 2, -(Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(180), math.radians(270)],
		['linea', 'Vertical', -Largo_X / 2, -(Alto_X - 2 * Radio_X) / 2, -Largo_X / 2, (Alto_X - 2 * Radio_X) / 2],
		['arco', -(Largo_X - 2 * Radio_X) / 2, (Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(90), math.radians(180)]
	]
	return Lista01


def Actualizar_Lista02(Val_X, Val_Y):
	
	# Validamos los argumentos de la funcion
	if not type(Val_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista02 \n\t {type(Val_X) = }')
	
	if not type(Val_Y) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista02 \n\t {type(Val_Y) = }')
	
	
	# Ubicacion de los agujeros
	Lista02 = [
		['Arriba',     1, Val_Y, 'Derecha',    1, Val_X],
		['Derecha',    1, Val_X, 'Arriba',     1, Val_Y],
		['Derecha',    1, Val_X, 'Abajo',     -1, Val_Y],
		['Abajo',     -1, Val_Y, 'Derecha',    1, Val_X],
		['Abajo',     -1, Val_Y, 'Izquierda', -1, Val_X],
		['Izquierda', -1, Val_X, 'Abajo',     -1, Val_Y],
		['Izquierda', -1, Val_X, 'Arriba',     1, Val_Y],
		['Arriba',     1, Val_Y, 'Izquierda', -1, Val_X]
	]
	
	return Lista02
	
	
def Actualizar_Lineal_Lista03(Lista02, DeltaVal_X, DeltaVal_Y, Radio_Agujero, Inicio_Centro = False):
	
	'''
	Nota:
		Lista02: Es la lista que se usara para indicar la direccion en que se dibujaran los circulos
		DeltaVal_X: Es la lista de las separaciones de los centros de los circulos en el eje X
		DeltaVal_Y: Es la lista de las separaciones de los centros de los circulos en el eje Y
		Radio_Agujero: Es el radio del circulo a dibujar
		Inicio_Centro: Es la opcion de separar el primer circulo del punto de inicio
	'''
	
	# Validamos los argumentos de la funcion
	if not type(Lista02) is list:
		raise TypeError(f'\n\n\t Mensaje = No es una Lista \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(Lista02) = }')
		
	if not type(DeltaVal_X) is list:
		raise TypeError(f'\n\n\t Mensaje = No es una Lista \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(DeltaVal_X) = }')
		
	if not type(DeltaVal_Y) is list:
		raise TypeError(f'\n\n\t Mensaje = No es una Lista \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(DeltaVal_Y) = }')
	
	if not type(Radio_Agujero) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(Radio_Agujero) = }')
		
	if not type(Inicio_Centro) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Bolleano \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(Inicio_Centro) = }')
	
	
	# Ubicacion de lo agujeros con vectores
	Lista03 = []
	for j in range(0, len(Lista02)):
		
		if (Lista02[j][3] == 'Derecha' or Lista02[j][3] == 'Abajo') and Inicio_Centro == True:
			Val_Ini = 1
		else:
			Val_Ini = 0
			
		if Lista02[j][0] == 'Arriba':
			for k in range(Val_Ini, len(DeltaVal_X)):
				Lista_Temp = [App.Vector(Lista02[j][4] * DeltaVal_X[k], Lista02[j][1] * Lista02[j][2], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Abajo':
			for k in range(Val_Ini, len(DeltaVal_X)):
				Lista_Temp = [App.Vector(Lista02[j][4] * DeltaVal_X[k], Lista02[j][1] * Lista02[j][2], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Derecha':
			for k in range(Val_Ini, len(DeltaVal_Y)):
				Lista_Temp = [App.Vector(Lista02[j][1] * Lista02[j][2],Lista02[j][4] * DeltaVal_Y[k], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Izquierda':
			for k in range(Val_Ini, len(DeltaVal_Y)):
				Lista_Temp = [App.Vector(Lista02[j][1] * Lista02[j][2],Lista02[j][4] * DeltaVal_Y[k], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
	
	return Lista03
	
	
def Actualizar_Polar_Lista03(Lista02, Delta_X, Delta_Y, Radio_Agujero, Lista03 = []):
	
	'''
	Nota:
		Lista02: Es la lista que se usara para indicar la direccion en que se dibujaran los circulos
		DeltaVal_X: Es la lista de las separaciones de los centros de los circulos en el eje X
		DeltaVal_Y: Es la lista de las separaciones de los centros de los circulos en el eje Y
		Radio_Agujero: Es el radio del circulo a dibujar
	'''
	# Validamos los argumentos de la funcion
	if not type(Lista02) is list:
		raise TypeError(f'\n\n\t Mensaje = No es una Lista \n\t Funcion = Actualizar_Polar_Lista03 \n\t {type(Lista02) = }')
		
	if not type(Delta_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Polar_Lista03 \n\t {type(Delta_X) = }')
		
	if not type(Delta_Y) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Polar_Lista03 \n\t {type(Delta_Y) = }')
	
	if not type(Radio_Agujero) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Polar_Lista03 \n\t {type(Radio_Agujero) = }')
	
	
	
	# Ubicacion de lo agujeros con vectores
	Margen = 12
	Separacion = 38
	Radio_Eje = Lista02[1][5] - Delta_X
	Angulo_Delta = Separacion / Radio_Eje
	Cuerda_Eje = Radio_Eje * math.radians(90) / 2 - Margen
	Total_Circulo01 = 1 + 2 * math.floor(Cuerda_Eje / Separacion)
	Total_Circulo02 = 2 + 2 * math.floor((Cuerda_Eje - Separacion / 2) / Separacion)
	Angulo_Ini01 = math.radians(45) - (Total_Circulo01 - 1) * Angulo_Delta / 2
	Angulo_Ini02 = math.radians(45) - (Total_Circulo02 - 1) * Angulo_Delta / 2
	
	
	if Total_Circulo01 > Total_Circulo02:
		Total_Circulo03 = Total_Circulo01
		Angulo_Ini03 = Angulo_Ini01
	else:
		Total_Circulo03 = Total_Circulo02
		Angulo_Ini03 = Angulo_Ini02
	
		
	for j in range(0, len(Lista02)):
		
		if Lista02[j][0] == 'Arriba' and Lista02[j][3] == 'Derecha':
			for k in range(0, Total_Circulo03):
				Lista_Temp = [App.Vector(Lista02[j][4] * Lista02[j][5] - Radio_Eje * (1 - math.cos(Angulo_Ini03 + k * Angulo_Delta)), Lista02[j][1] * Delta_Y + Radio_Eje * math.sin(Angulo_Ini03 + k * Angulo_Delta), 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Arriba' and Lista02[j][3] == 'Izquierda':
			for k in range(0, Total_Circulo03):
				Lista_Temp = [App.Vector(Lista02[j][4] * Lista02[j][5] + Radio_Eje * (1 - math.cos(Angulo_Ini03 + k * Angulo_Delta)), Lista02[j][1] * Delta_Y + Radio_Eje * math.sin(Angulo_Ini03 + k * Angulo_Delta), 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Abajo' and Lista02[j][3] == 'Derecha':
			for k in range(0, Total_Circulo03):
				Lista_Temp = [App.Vector(Lista02[j][4] * Lista02[j][5] - Radio_Eje * (1 - math.cos(Angulo_Ini03 + k * Angulo_Delta)), Lista02[j][1] * Delta_Y - Radio_Eje * math.sin(Angulo_Ini03 + k * Angulo_Delta), 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Abajo' and Lista02[j][3] == 'Izquierda':
			for k in range(0, Total_Circulo03):
				Lista_Temp = [App.Vector(Lista02[j][4] * Lista02[j][5] + Radio_Eje * (1 - math.cos(Angulo_Ini03 + k * Angulo_Delta)), Lista02[j][1] * Delta_Y - Radio_Eje * math.sin(Angulo_Ini03 + k * Angulo_Delta), 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		
	return Lista03
	
	
	
def Limpiar_Pantalla():
	mw = Gui.getMainWindow()
	rv = mw.findChild(QtGui.QTextEdit, "Report view")
	rv.clear()
	
	pc = mw.findChild(QtGui.QPlainTextEdit,"Python console")
	pc.onClearConsole()
	











#! crear Boceto Cuerpo
def Crear_Boceto_Cuerpo(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Cuerpo \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Cuerpo \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Cuerpo \n\t {type(Radio_Pral) = }')
	
	
	Largo_Y = Largo_Total
	Alto_Y = Alto_Total
	Radio_Y = Radio_Pral
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista01, Boceto_LVS_C, Largo_Total = Largo_Y, Alto_Total = Alto_Y)
	
	
	Largo_Y += 1 + 1
	Alto_Y += 1 + 1
	Radio_Y += 1
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista01, Boceto_LVS_C, Desfase = 1)
	
	
	Largo_Y += 14 + 14
	Alto_Y += 14 + 14
	Radio_Y += 14
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista01, Boceto_LVS_C, Desfase = 14)
	
	
	Largo_Y += 1 + 1
	Alto_Y += 1 + 1
	Radio_Y += 1
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista01, Boceto_LVS_C, Desfase = 1)
	
	
	# Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, 
	# Separacion = 76, Inicio_Centro = False, Incluir_Arco = False, Grupo_Base = ['', ''], Titulo_X = 'Radio'):
	Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_LVS_C, 1.5, Grupo_Base = ['Grupo_002', 'Grupo_003'], Titulo_X = 'Hoyo')
	


#! crear Boceto Tapadera
def Crear_Boceto_Tapadera(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Tapadera \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Tapadera \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Tapadera \n\t {type(Radio_Pral) = }')
	
	
	Largo_Y = Largo_Total
	Alto_Y = Alto_Total
	Radio_Y = Radio_Pral
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista01, Boceto_LVS_T, Largo_Total = Largo_Y, Alto_Total = Alto_Y, Guia_X = True)
	
	
	Largo_Y += 1.5 + 1.5
	Alto_Y += 1.5 + 1.5
	Radio_Y += 1.5
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista01, Boceto_LVS_T, Desfase = 1.5)
	
	
	Largo_Y += 13 + 13
	Alto_Y += 13 + 13
	Radio_Y += 13
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista01, Boceto_LVS_T, Desfase = 13)
	
	
	# Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, 
	# Separacion = 76, Inicio_Centro = False, Incluir_Arco = False, Grupo_Base = ['', ''], Titulo_X = 'Radio'):
	Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_LVS_T, 1.5, Grupo_Base = ['Grupo_002', 'Grupo_003'], Titulo_X = 'Hoyo')
	
	

#! crear Boceto Pieza 1
def Crear_Boceto_P1(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P1 \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P1 \n\t {type(Alto_Total) = }')
	
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P1 \n\t {type(Radio_Pral) = }')
	
	
	Origen_Y = -(Alto_Total / 2) - 15
	Origen_X = 0
	
	if ((Largo_Total - 2 * Radio_Pral) / 2) >= 33:
	
		Lista04 = [
			['linea', 'Horizontal', Origen_X, Origen_Y, Origen_X + 33, Origen_Y],
			['linea', 'Vertical', Origen_X + 33, Origen_Y, Origen_X + 33, Origen_Y - 1],
			['arco', Origen_X + 33, Origen_Y - 6, App.Vector(0, 0, 1), 5, math.radians(90), math.radians(180)],
			['linea', 'Vertical', Origen_X + 28, Origen_Y - 6, Origen_X + 28, Origen_Y - 16],
			['arco', Origen_X + 23, Origen_Y - 16, App.Vector(0, 0, 1), 5, math.radians(270), math.radians(360)],
			['linea', 'Horizontal', Origen_X + 23, Origen_Y - 21, Origen_X, Origen_Y - 21]
		]
	
	else:
		
		Desfase_X = 33 - (Largo_Total - 2 * Radio_Pral) / 2
		Radio_CC = Radio_Pral + (1 + 14 + 1) + 5
		Desfase_Y = Radio_CC - math.sqrt(Radio_CC**2 - Desfase_X**2)
		Angulo_Desfase = math.acos(Desfase_X / Radio_CC)
		
		Lista04 = [
			['linea', 'Horizontal', Origen_X, Origen_Y - 21, Origen_X + 23, Origen_Y - 21],
			['arco', Origen_X + 23, Origen_Y - 16, App.Vector(0, 0, 1), 5, math.radians(270), math.radians(360)],
			['linea', 'Vertical', Origen_X + 28, Origen_Y - 16, Origen_X + 28, Origen_Y - 6 + Desfase_Y],
			['arco', Origen_X + 33, Origen_Y - 6 + Desfase_Y, App.Vector(0, 0, 1), 5, math.radians(180) - Angulo_Desfase, math.radians(180)],
			['linea', 'Oblicua', Origen_X + 33 - 5 * math.cos(Angulo_Desfase), Origen_Y - 6 + Desfase_Y + 5 * math.sin(Angulo_Desfase), Origen_X + 33 - 6 * math.cos(Angulo_Desfase), Origen_Y - 6 + Desfase_Y + 6 * math.sin(Angulo_Desfase)],
			['arco', (Largo_Total - 2 * Radio_Pral) / 2, -(Alto_Total - 2 * Radio_Pral) / 2, App.Vector(0, 0, 1), Radio_CC - 6, math.radians(270), math.radians(360) - Angulo_Desfase],
			['linea', 'Horizontal', (Largo_Total - 2 * Radio_Pral) / 2, Origen_Y, Origen_X, Origen_Y]
		]
		
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista04, Boceto_LVS_P1, Simetria = True)
	
	
	
	#$ crear Boceto Hoyo Pieza 1
	Lista05 = [
		['linea', 'Horizontal', Origen_X + 2, Origen_Y - 11, Origen_X + 25, Origen_Y - 11],
		['arco', Origen_X + 25, Origen_Y - 12, App.Vector(0, 0, 1), 1, math.radians(0), math.radians(90)],
		['linea', 'Vertical', Origen_X + 26, Origen_Y - 12, Origen_X + 26, Origen_Y - 16],
		['arco', Origen_X + 23, Origen_Y - 16, App.Vector(0, 0, 1), 3, math.radians(270), math.radians(360)],
		['linea', 'Horizontal', Origen_X + 23, Origen_Y - 19, Origen_X + 2, Origen_Y - 19],
		['arco', Origen_X + 2, Origen_Y - 18, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
		['linea', 'Vertical', Origen_X + 1, Origen_Y - 18, Origen_X + 1, Origen_Y - 12],
		['arco', Origen_X + 2, Origen_Y - 12, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista05, Boceto_LVS_H_P1, Espejo = True)
	
	
	Lista06 = [
		['linea', 'Horizontal', Origen_X + 2, Origen_Y - 1, Origen_X + 33 - 4 * math.sqrt(3), Origen_Y - 1],
		['arco', Origen_X + 33 - 4 * math.sqrt(3), Origen_Y - 2, App.Vector(0, 0, 1), 1, math.radians(-30), math.radians(90)],
		['arco', Origen_X + 33, Origen_Y - 6, App.Vector(0, 0, 1), 7, math.radians(150), math.radians(180)],
		['linea', 'Vertical', Origen_X + 26, Origen_Y - 6, Origen_X + 26, Origen_Y - 8],
		['arco', Origen_X + 25, Origen_Y - 8, App.Vector(0, 0, 1), 1, math.radians(270), math.radians(360)],
		['linea', 'Horizontal', Origen_X + 25, Origen_Y - 9, Origen_X + 2, Origen_Y - 9],
		['arco', Origen_X + 2, Origen_Y - 8, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
		['linea', 'Vertical', Origen_X + 1, Origen_Y - 8, Origen_X + 1, Origen_Y - 2],
		['arco', Origen_X + 2, Origen_Y - 2, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista06, Boceto_LVS_H_P1, Espejo = True)
	
	

#! crear Boceto Pieza 2
def Crear_Boceto_P2(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P2 \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P2 \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P2 \n\t {type(Radio_Pral) = }')
	
	Origen_Y = (Alto_Total / 2) + 15
	Origen_X = 0
	
	if ((Largo_Total - 2 * Radio_Pral) / 2) > 45:
	
		Lista07 = [
			['linea', 'Horizontal', Origen_X, Origen_Y + 7, Origen_X + 41, Origen_Y + 7],
			['arco', Origen_X + 41, Origen_Y + 5, App.Vector(0, 0, 1), 2, math.radians(0), math.radians(90)],
			['linea', 'Vertical', Origen_X + 43, Origen_Y + 5, Origen_X + 43, Origen_Y + 3],
			['arco', Origen_X + 45, Origen_Y + 3, App.Vector(0, 0, 1), 2, math.radians(180), math.radians(270)],
			['linea', 'Vertical', Origen_X + 45, Origen_Y + 1, Origen_X + 45, Origen_Y],
			['linea', 'Horizontal', Origen_X + 45, Origen_Y, Origen_X, Origen_Y]
		]
		
	else:
		
		Desfase_X = 45 - (Largo_Total - 2 * Radio_Pral) / 2
		Radio_CC = Radio_Pral + (1 + 14 + 1) + 2
		Desfase_Y = Radio_CC - math.sqrt(Radio_CC**2 - Desfase_X**2)
		Angulo_Desfase = math.acos(Desfase_X / Radio_CC)
		
		Lista07 = [
			['linea', 'Horizontal', Origen_X, Origen_Y + 7, Origen_X + 41, Origen_Y + 7],
			['arco', Origen_X + 41, Origen_Y + 5, App.Vector(0, 0, 1), 2, math.radians(0), math.radians(90)],
			['linea', 'Vertical', Origen_X + 43, Origen_Y + 5, Origen_X + 43, Origen_Y + 3 - Desfase_Y],
			['arco', Origen_X + 45, Origen_Y + 3 - Desfase_Y, App.Vector(0, 0, 1), 2, math.radians(180), math.radians(180) + Angulo_Desfase],
			['linea', 'Oblicua', Origen_X + 45 - 2 * math.cos(Angulo_Desfase), Origen_Y + 3 - Desfase_Y - 2 * math.sin(Angulo_Desfase), Origen_X + 45 - 3 * math.cos(Angulo_Desfase), Origen_Y + 3 - Desfase_Y - 3 * math.sin(Angulo_Desfase)],
			['arco', (Largo_Total - 2 * Radio_Pral) / 2, (Alto_Total - 2 * Radio_Pral) / 2, App.Vector(0, 0, 1), Radio_CC - 3, Angulo_Desfase, math.radians(90)],
			['linea', 'Horizontal', (Largo_Total - 2 * Radio_Pral) / 2, Origen_Y, Origen_X, Origen_Y]
		]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista07, Boceto_LVS_P2, Simetria = True)
	
	
	
	#$ crear Boceto Hoyo Pieza 2
	Lista08 = [
		['linea', 'Horizontal', Origen_X + 2, Origen_Y + 5, Origen_X + 35, Origen_Y + 5],
		['arco', Origen_X + 2, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)],
		['linea', 'Vertical', Origen_X + 1, Origen_Y + 4, Origen_X + 1, Origen_Y + 2],
		['arco', Origen_X + 2, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
		['linea', 'Horizontal', Origen_X + 2, Origen_Y + 1, Origen_X + 35, Origen_Y + 1],
		['arco', Origen_X + 35, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(270), math.radians(360)],
		['linea', 'Vertical', Origen_X + 36, Origen_Y + 2, Origen_X + 36, Origen_Y + 4],
		['arco', Origen_X + 35, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(0), math.radians(90)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista08, Boceto_LVS_H_P2, Espejo = True)
	
	
	Lista09 = [
		['linea', 'Horizontal', Origen_X + 39, Origen_Y + 5, Origen_X + 40, Origen_Y + 5],
		['arco', Origen_X + 39, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)],
		['linea', 'Vertical', Origen_X + 38, Origen_Y + 4, Origen_X + 38, Origen_Y + 2],
		['arco', Origen_X + 39, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
		['linea', 'Horizontal', Origen_X + 39, Origen_Y + 1, Origen_X + 40, Origen_Y + 1],
		['arco', Origen_X + 40, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(270), math.radians(360)],
		['linea', 'Vertical', Origen_X + 41, Origen_Y + 2, Origen_X + 41, Origen_Y + 4],
		['arco', Origen_X + 40, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(0), math.radians(90)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista09, Boceto_LVS_H_P2, Espejo = True)
	
	


#! Crear_Boceto_Iman
def Crear_Boceto_Iman(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Iman \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Iman \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Iman \n\t {type(Radio_Pral) = }')
	
	
	Largo_Y = Largo_Total
	Alto_Y = Alto_Total
	Radio_Y = Radio_Pral
	
	Largo_Y += 1 + 1
	Alto_Y += 1 + 1
	Radio_Y += 1
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista01, Boceto_LVS_I, Largo_Total = Largo_Y, Alto_Total = Alto_Y, Guia_X = True)
	
	
	Largo_Y += 14 + 14
	Alto_Y += 14 + 14
	Radio_Y += 14
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, Desfase = -1, Guia_X = False):
	Crear_Contorno(Lista01, Boceto_LVS_I, Desfase = 14, Guia_X = True)
	
	
	# Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, 
	# Separacion = 76, Inicio_Centro = False, Incluir_Arco = False, Grupo_Base = ['', ''], Titulo_X = 'Radio'):
	Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_LVS_I, 7, 76, True, True, Grupo_Base = ['Grupo_001', 'Grupo_002'], Titulo_X = 'Iman')
	


#! Estas son las funciones para las partes que forman el Hoop
def Crear_Hoop(Largo_Total = '156 mm', Alto_Total = '156 mm', Radio_Pral = '35 mm'):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int, str):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int, str):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int, str):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t {type(Radio_Pral) = }')
	
	# aqui convertimos el texto a numero con las unidades por defecto en FreeCAD
	try:
		LT = App.Units.Quantity(Largo_Total).Value
	except:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t (Largo_Total) = "{Largo_Total}"  ==>  {type(Largo_Total)}')
	
	try:
		AT = App.Units.Quantity(Alto_Total).Value
	except:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t (Alto_Total) = "{Alto_Total}"  ==>  {type(Alto_Total)}')
	try:
		RP = App.Units.Quantity(Radio_Pral).Value
	except:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t (Radio_Pral) = "{Radio_Pral}"  ==>  {type(Radio_Pral)}')
	
	
	# Limpiar_Pantalla():
	Limpiar_Pantalla()
	
	# Crear_Contenedor_2D():
	Crear_Contenedor_2D()
	
	# Crear_Boceto_Cuerpo(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_Cuerpo(LT, AT, RP)
	
	# Crear_Boceto_Tapadera(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_Tapadera(LT, AT, RP)
	
	# Crear_Boceto_P1(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_P1(LT, AT, RP)
	
	# Crear_Boceto_P2(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_P2(LT, AT, RP)
	
	# Crear_Boceto_Iman(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_Iman(LT, AT, RP)
	



#! Variable Global
#$ Esta es la memoria de los Objetos 2D para revision y analisis
# Lista_Linea = [
#	ID objeto, ID punto inicial, ID punto final, nombre del Objeto, nombre del Contenedor, 
#	Longitud / Radio, Vector punto inicial, Vector punto final, Vector centro / NA, nombre del Grupo
# ]
Lista_Linea = []

# Lista_Restriccion = [
#	ID restriccion, ID objeto 1, ID punto inicial, ID objeto 2, ID punto final, Magnitud, nombre de la restriccion, nombre del Grupo
# ]
Lista_Restriccion = []


dias = ('Lun', 'Mar', 'Mie', 'Jue', 'Vie', 'Sab', 'Dom')

Ini = time.time()

#! Esta es la funcion que inicia la Macro
# Crear_Hoop(Largo_Total, Alto_Total, Radio_Pral):
Crear_Hoop('600 mm', '600 mm', '100 mm')

# '156 mm', '156 mm', '35 mm'
# '294 mm', '212 mm', '35 mm'
# '450 mm', '450 mm', '100 mm'



print(f'{len(Lista_Linea) = }')
for l in Lista_Linea:
	print(l)

print()
print(f'{len(Lista_Restriccion) = }')
for l in Lista_Restriccion:
	print(l)



Fin = time.time()

indice = datetime.date.weekday(datetime.datetime.now())

print()

App.Console.PrintMessage(f'Fin de la {Pieza_H1.Label} en {round(Fin - Ini, 2)} seg\n')

print(f'{dias[indice]}  {time.strftime("%d/%m/%Y  %H:%M:%S", time.localtime())}')


'''
# Ejemplo mover la pieza usando una ventana flotante de PySide
	
	from PySide import QtGui
	val = QtGui.QInputDialog.getText(None, 'Mover Objeto', 'Ingrese los valores \n separados por coma. \n Ejemplo: 100,0,0')[0]
	myVal = tuple(val.split(','))
	Pieza_H1.Placement.Base = App.Vector(myVal)
	
'''




# Macro End: C:\Users\OWNER\AppData\Roaming\FreeCAD\Macro\Hoop_1.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
