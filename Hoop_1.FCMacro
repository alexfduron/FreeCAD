# -*- coding: utf-8 -*-

'''
copyright (c) 2024
AFD

This program is free software, you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public Licence (LGPL)
as published by the Free Software Fundation; either version 2 of 
the Licence, or (at your option) any Later version.
for detail see the LICENCE text file.

Thi program is distributed in the hope that it will be useful
but WITHOUT ANY WARRANTY, without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU Library General Public Licence for more details.

You should have received a copy of the GNU Library General Public
Licence along with this program, if not, write to the Free Software 
Foundation Inc. 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.

'''

# Macro Begin: C:\Users\OWNER\AppData\Roaming\FreeCAD\Macro\Hoop_1.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
import FreeCAD as App
import FreeCADGui as Gui
import PartDesignGui
import PartDesign
import Sketcher
import Part
import math
from PySide import QtGui





#! Estos son las funciones para las Piezas, Cuerpos, Grupos, Bocetos
def Crear_Plano():
	# Tomamos el archivo activo
	global Plano
	Plano = App.activeDocument()


def Crear_Grupo(Titulo, Etiqueta = '', Objeto_X = ''):
	Grupo_X = Plano.addObject('App::DocumentObjectGroup', Titulo)
	Plano.Tip = Grupo_X
	if Etiqueta == '':
		Grupo_X.Label = Titulo
	else:
		Grupo_X.Label = Etiqueta
	if Objeto_X == '':
		Plano.Tip = Grupo_X
	else:
		Objeto_X.addObject(Grupo_X)
	Plano.recompute
	return Grupo_X


def Crear_Pieza():
	Crear_Plano()
	Pieza_X = Plano.addObject('App::Part','Part_H001')
	Plano.Tip = Pieza_X
	Pieza_X.Label = 'Pieza_H001'
	Plano.recompute()
	return Pieza_X


def Crear_Cuerpo(Titulo, Etiqueta = '', Objeto_X = ''):
	Cuerpo_X = Plano.addObject('PartDesign::Body', Titulo)
	if Etiqueta == '':
		Cuerpo_X.Label = Titulo
	else:
		Cuerpo_X.Label = Etiqueta
	if Objeto_X == '':
		Plano.Tip = Cuerpo_X
	else:
		Objeto_X.addObject(Cuerpo_X)
	Plano.recompute
	return Cuerpo_X


def Crear_Boceto(Titulo, Etiqueta = '', Objeto_X = '', Plano_X = ''):
	Boceto_X = Plano.addObject('Sketcher::SketchObject', Titulo)
	Plano.Tip = Boceto_X
	if Plano_X == '':
		Plano_X = 'XY_Plane'
	if Etiqueta == '':
		Boceto_X.Label = Titulo
	else:
		Boceto_X.Label = Etiqueta
	Boceto_X.MapMode = 'FlatFace'
	if Objeto_X == '':
		Plano.Tip = Boceto_X
		Cuerpo_New = Crear_Cuerpo('New_Body', '', Pieza_H1)
		Cuerpo_New.addObject(Boceto_X)
		for k in Cuerpo_New.Origin.OriginFeatures:
			if k.Role == Plano_X:
				XY_Plano = k
		Boceto_X.AttachmentSupport = (XY_Plano, [''])
		del XY_Plano
	else:
		Objeto_X.addObject(Boceto_X)
		for k in Objeto_X.Origin.OriginFeatures:
			if k.Role == Plano_X:
				XY_Plano = k
		Boceto_X.AttachmentSupport = (XY_Plano, [''])
		del XY_Plano
	Plano.recompute
	return Boceto_X	





#! Estos son los planos en 2D
def Crear_Contenedor_2D():
	
	### Begin command Std_Part
	global Pieza_H1
	Pieza_H1 = Crear_Pieza()
	
	
	### Begin command Std_Group
	global Grupo_LH1
	Grupo_LH1 = Crear_Grupo('Group_LH001', '', Pieza_H1)
	
	
	### Begin command PartDesign_Body
	global Cuerpo_LH1
	Cuerpo_LH1 = Crear_Cuerpo('Body_LH001', '', Grupo_LH1)
	
	
	### Begin command PartDesign_Sketch
	global Boceto_LVS_C
	Boceto_LVS_C = Crear_Boceto('Sketch_LVS_C001', 'Sketch_LVS_Cuerpo', Cuerpo_LH1)
	global Boceto_LVS_T
	Boceto_LVS_T = Crear_Boceto('Sketch_LVS_T001', 'Sketch_LVS_Tapadera', Cuerpo_LH1)
	global Boceto_LVS_P1
	Boceto_LVS_P1 = Crear_Boceto('Sketch_LVS_P1001', 'Sketch_LVS_Pieza1', Cuerpo_LH1)
	global Boceto_LVS_H_P1
	Boceto_LVS_H_P1 = Crear_Boceto('Sketch_LVS_H_P1001', 'Sketch_LVS_Hoyo_Pieza1', Cuerpo_LH1)
	global Boceto_LVS_P2
	Boceto_LVS_P2 = Crear_Boceto('Sketch_LVS_P2001', 'Sketch_LVS_Pieza2', Cuerpo_LH1)
	global Boceto_LVS_H_P2
	Boceto_LVS_H_P2 = Crear_Boceto('Sketch_LVS_H_P2001', 'Sketch_LVS_Hoyo_Pieza2', Cuerpo_LH1)
	global Boceto_LVS_I
	Boceto_LVS_I = Crear_Boceto('Sketch_LVS_I001', 'Sketch_LVS_Iman', Cuerpo_LH1)
	
	
	
	#! Estos son los planos en 3D
	
	### Begin command PartDesign_Body
	global Cuerpo_H1
	Cuerpo_H1 = Crear_Cuerpo('Body_H001', '', Pieza_H1)
	
	
	### Begin command PartDesign_Sketch
	global Boceto_H1
	Boceto_H1 = Crear_Boceto('Sketch_H001', '', Cuerpo_H1)
	





#! Estos son las funciones para crear Lineas, Arcos, Circulos
def Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Indice = '', Simetria = False):
	# aqui guardamos el ID de la linea.
	Lista_Linea.append(list(Boceto_X.addGeometry([Part.LineSegment(Pt1, Pt2)], False)))
	# aqui creamos la restriccion Horizontal o Vertical de la linea.
	if Restriccion_X != '':
		Boceto_X.addConstraint(Sketcher.Constraint(Restriccion_X, Lista_Linea[-1][0]))
	# aqui redondeamos los valores numericos de los vectores
	Pt1_Temp = App.Vector(round(Pt1.x, 10), round(Pt1.y, 10), round(Pt1.z, 10))
	Pt2_Temp = App.Vector(round(Pt2.x, 10), round(Pt2.y, 10), round(Pt2.z, 10))
	# aqui guardamos el punto inicial => (1) y punto final => (2) de la linea.
	if Indice != '':
		# aqui el Indice cero nos indica que es la primera linea de la figura cerrada.
		if Indice == 0 and Simetria == False:
			Lista_Linea[-1].append(1)
			Lista_Linea[-1].append(2)
		# aqui el Indice uno nos indica que es la segunda linea de la figura cerrada,
		# tambien tiene la opcion de modificar la primera linea en caso
		# de que los puntos esten invertidos.
		elif Indice == 1:
			if Lista_Linea[-2][7] == Pt1_Temp:
				if Simetria == False:
					Lista_Linea[-2][1] = 1
					Lista_Linea[-2][2] = 2
				Lista_Linea[-1].append(1)
				Lista_Linea[-1].append(2)
			elif Lista_Linea[-2][7] == Pt2_Temp:
				if Simetria == False:
					Lista_Linea[-2][1] = 1
					Lista_Linea[-2][2] = 2
				Lista_Linea[-1].append(2)
				Lista_Linea[-1].append(1)
			elif Lista_Linea[-2][6] == Pt1_Temp:
				if Simetria == False:
					Lista_Linea[-2][1] = 2
					Lista_Linea[-2][2] = 1
				Lista_Linea[-1].append(1)
				Lista_Linea[-1].append(2)
			elif Lista_Linea[-2][6] == Pt2_Temp:
				if Simetria == False:
					Lista_Linea[-2][1] = 2
					Lista_Linea[-2][2] = 1
				Lista_Linea[-1].append(2)
				Lista_Linea[-1].append(1)
		# aqui el Indice nos indica que son todas las lineas de la figura cerrada.
		else:
			if Lista_Linea[-2][2] == 1:
				if Lista_Linea[-2][6] == Pt1_Temp:
					Lista_Linea[-1].append(1)
					Lista_Linea[-1].append(2)
				elif Lista_Linea[-2][6] == Pt2_Temp:
					Lista_Linea[-1].append(2)
					Lista_Linea[-1].append(1)
			elif Lista_Linea[-2][2] == 2:
				if Lista_Linea[-2][7] == Pt1_Temp:
					Lista_Linea[-1].append(1)
					Lista_Linea[-1].append(2)
				elif Lista_Linea[-2][7] == Pt2_Temp:
					Lista_Linea[-1].append(2)
					Lista_Linea[-1].append(1)
	# aqui guardamos el nombre de la linea.
	Lista_Linea[-1].append('linea')
	# aqui guardamos el Boceto que contiene la linea.
	Lista_Linea[-1].append(Boceto_X.Label)
	# aqui guardamos la marnitud de la linea.
	Pt3 = Pt2 - Pt1
	Lista_Linea[-1].append(round(Pt3.Length, 10))
	# aqui guardamos el punto inicial de la linea.
	Lista_Linea[-1].append(Pt1_Temp)
	# aqui guardamos el punto final de la linea.
	Lista_Linea[-1].append(Pt2_Temp)
	# aqui guardamos el punto centro => N/A.
	Lista_Linea[-1].append(0)
	
	
def Crear_Arco(Pt1, Eje, Radio, Boceto_X, Ang_Ini, Ang_Fin, Indice = '', Simetria = False):
	# aqui guardamos el ID del arco.
	Lista_Linea.append(list(Boceto_X.addGeometry([Part.ArcOfCircle(Part.Circle(Pt1, Eje , Radio), Ang_Ini, Ang_Fin)], False)))
	# aqui creamos la restriccion Radio del arco.
	Boceto_X.addConstraint(Sketcher.Constraint('Radius', Lista_Linea[-1][0], Radio))
	# aqui creamos los puntos de los extremos del arco con los valores numericos redondeados
	Pt1_Temp = App.Vector(round(Pt1.x + Radio * math.cos(Ang_Ini), 10), round(Pt1.y + Radio * math.sin(Ang_Ini), 10), round(Pt1.z, 10))
	Pt2_Temp = App.Vector(round(Pt1.x + Radio * math.cos(Ang_Fin), 10), round(Pt1.y + Radio * math.sin(Ang_Fin), 10), round(Pt1.z, 10))
	# aqui guardamos el punto inicial => (1) y punto final => (2) del arco.
	if Indice != '':
		# aqui el Indice cero nos indica que es el primer arco de la figura cerrada.
		if Indice == 0 and Simetria == False:
			Lista_Linea[-1].append(2)
			Lista_Linea[-1].append(1)
		# aqui el Indice uno nos indica que es el segundo arco de la figura cerrada,
		# tambien tiene la opcion de modificar el primer arco en caso
		# de que los puntos esten invertidos.
		elif Indice == 1:
			if Lista_Linea[-2][7] == Pt1_Temp:
				if Simetria == False:
					Lista_Linea[-2][1] = 1
					Lista_Linea[-2][2] = 2
				Lista_Linea[-1].append(1)
				Lista_Linea[-1].append(2)
			elif Lista_Linea[-2][7] == Pt2_Temp:
				if Simetria == False:
					Lista_Linea[-2][1] = 1
					Lista_Linea[-2][2] = 2
				Lista_Linea[-1].append(2)
				Lista_Linea[-1].append(1)
			elif Lista_Linea[-2][6] == Pt1_Temp:
				if Simetria == False:
					Lista_Linea[-2][1] = 2
					Lista_Linea[-2][2] = 1
				Lista_Linea[-1].append(1)
				Lista_Linea[-1].append(2)
			elif Lista_Linea[-2][6] == Pt2_Temp:
				if Simetria == False:
					Lista_Linea[-2][1] = 2
					Lista_Linea[-2][2] = 1
				Lista_Linea[-1].append(2)
				Lista_Linea[-1].append(1)	
		# aqui el Indice nos indica que son todas los arcos de la figura cerrada.
		else:
			if Lista_Linea[-2][2] == 1:
				if Lista_Linea[-2][6] == Pt1_Temp:
					Lista_Linea[-1].append(1)
					Lista_Linea[-1].append(2)
				elif Lista_Linea[-2][6] == Pt2_Temp:
					Lista_Linea[-1].append(2)
					Lista_Linea[-1].append(1)
			elif Lista_Linea[-2][2] == 2:
				if Lista_Linea[-2][7] == Pt1_Temp:
					Lista_Linea[-1].append(1)
					Lista_Linea[-1].append(2)
				elif Lista_Linea[-2][7] == Pt2_Temp:
					Lista_Linea[-1].append(2)
					Lista_Linea[-1].append(1)
	# aqui guardamos el nombre del arco.
	Lista_Linea[-1].append('arco')
	# aqui guardamos el Boceto que contiene al arco.
	Lista_Linea[-1].append(Boceto_X.Label)
	# aqui guardamos el radio del arco.
	Lista_Linea[-1].append(round(Radio, 10))
	# aqui guardamos el punto inicial del arco.
	Lista_Linea[-1].append(Pt1_Temp)
	# aqui guardamos el punto final del arco.
	Lista_Linea[-1].append(Pt2_Temp)
	# aqui guardamos el punto central del arco.
	Lista_Linea[-1].append(App.Vector(round(Pt1.x, 10), round(Pt1.y, 10), round(Pt1.z, 10)))


def Crear_Circulo(Pt1, Eje, Radio, Boceto_X):
	# aqui guardamos el ID del circulo.
	Lista_Linea.append(list(Boceto_X.addGeometry([Part.Circle(Pt1, Eje, Radio)], False)))
	# aqui creamos la restriccion Radio del circulo.
	Boceto_X.addConstraint(Sketcher.Constraint('Radius', Lista_Linea[-1][0], Radio))
	# aqui guardamos el punto inicial => (1) y punto final => (2) del circulo => N/A.
	Lista_Linea[-1].append(0)
	Lista_Linea[-1].append(0)
	# aqui guardamos el nombre del circulo.
	Lista_Linea[-1].append('circulo')
	# aqui guardamos el Boceto que contiene al circulo.
	Lista_Linea[-1].append(Boceto_X.Label)
	# aqui guardamos el radio del circulo.
	Lista_Linea[-1].append(round(Radio, 10))
	# aqui guardamos el punto inicial del circulo => N/A.
	Lista_Linea[-1].append(0)
	# aqui guardamos el punto final del circulo => N/A.
	Lista_Linea[-1].append(0)
	# aqui guardamos el punto central del circulo.
	Lista_Linea[-1].append(App.Vector(round(Pt1.x, 10), round(Pt1.y, 10), round(Pt1.z, 10)))


def Unir_Lineas(Boceto_X, Total_Lista):
	# aqui seleccionamos los 'n' ultimos elementos de la lista.
	for j in range(0, Total_Lista)[::-1]:
		# aqui seleccionamos el 'n + 1' elemento de la lista
		Valor_Futuro = (j - 1) % Total_Lista
		
		# aqui analizamos los vectores de dos lineas
		if Lista_Linea[::-1][j][3] == 'linea' and Lista_Linea[::-1][Valor_Futuro][3] == 'linea':
			if Lista_Linea[::-1][j][2] == 1:
				Vector01 = Lista_Linea[::-1][j][6] - Lista_Linea[::-1][j][7]
			else:
				Vector01 = Lista_Linea[::-1][j][7] - Lista_Linea[::-1][j][6]
			if Lista_Linea[::-1][Valor_Futuro][2] == 1:
				Vector02 = Lista_Linea[::-1][Valor_Futuro][6] - Lista_Linea[::-1][Valor_Futuro][7]
			else:
				Vector02 = Lista_Linea[::-1][Valor_Futuro][7] - Lista_Linea[::-1][Valor_Futuro][6]
			# calculamos el producto cruz entre los vectores linea
			Vec3 = Vector01.cross(Vector02)
			# si el producto cruz es igual a cero esto significa 
			# que las dos lineas estan alineados, los vectores son paralelos
			if abs(round(Vec3.Length, 5)) == 0:
				Opcion = 'paralelo'
			else:
				Opcion = 'perpendicular'
		
		# aqui analizamos los vectores de una linea y un arco
		if Lista_Linea[::-1][j][3] == 'linea' and Lista_Linea[::-1][Valor_Futuro][3] == 'arco':
			# calculamos el vector de la linea
			if Lista_Linea[::-1][j][2] == 1:
				Vector01 = Lista_Linea[::-1][j][6] - Lista_Linea[::-1][j][7]
			else:
				Vector01 = Lista_Linea[::-1][j][7] - Lista_Linea[::-1][j][6]
			
			# Si el punto inicial esta en la misma ubicacion del angulo inicial 
			# entonces el giro del angulo es en contra de las manecillas del reloj
			# por lo tanto su Normal Esperado es positiva.
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				Normal02_Esperada = App.Vector(0, 0, 1)
			else:
				Normal02_Esperada = App.Vector(0, 0, -1)
			# ahora se calcula el vector centro a extremo inicial del arco
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				Vector02_CE = Lista_Linea[::-1][Valor_Futuro][6] - Lista_Linea[::-1][Valor_Futuro][8]
			else:
				Vector02_CE = Lista_Linea[::-1][Valor_Futuro][7] - Lista_Linea[::-1][Valor_Futuro][8]
			# ahora se calculan los vectores perpendiculares al extremo inicial del arco
			Vector02_P1 = App.Vector(-Vector02_CE.y, Vector02_CE.x, 0)
			Vector02_P2 = App.Vector(Vector02_CE.y, -Vector02_CE.x, 0)
			# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
			Normal02_P1 = Vector02_CE.cross(Vector02_P1)
			Normal02_P2 = Vector02_CE.cross(Vector02_P2)
			# ahora calculamos la Normal Unitaria
			Normal02_P1 = Normal02_P1 / Normal02_P1.Length
			Normal02_P2 = Normal02_P2 / Normal02_P2.Length
			# ahora se compara el signo de la Normal Esperada con
			# el signo de la Normal perpendicular,
			# si ambos son iguales significa que el vector perpendicular el es correcto.
			if Normal02_Esperada == Normal02_P1:
				Vector02_P = Vector02_P1
			elif Normal02_Esperada == Normal02_P2:
				Vector02_P = Vector02_P2
			
			# calculamos el producto cruz entre los vectores linea y tangente del arco
			Vec3 = Vector01.cross(Vector02_P)
			# Ahora sumamos los dos vectores perpendiculares de los arcos
			Vector_T = Vector01 + Vector02_P
			# si el producto cruz es igual a cero
			# significa que los extremos de los arcos estan alineados.
			if abs(round(Vec3.Length, 5)) == 0:
				# si ambos vectores se suman y la magnitud es mayor al vector inicial
				# significa que los vectores estan en el mismo sentido.
				if Vector_T.Length > Vector01.Length:
					Opcion = 'paralelo'
				else:
					Opcion = 'perpendicular'
			else:
				Opcion = 'perpendicular'
			
			
		if Lista_Linea[::-1][j][3] == 'arco' and Lista_Linea[::-1][Valor_Futuro][3] == 'linea':
			# Si el punto inicial esta en la misma ubicacion del angulo inicial 
			# entonces el giro del angulo es en contra de las manecillas del reloj
			# por lo tanto su Normal Esperado es positiva.
			if Lista_Linea[::-1][j][1] == 1:
				Normal01_Esperada = App.Vector(0, 0, 1)
			else:
				Normal01_Esperada = App.Vector(0, 0, -1)
			# ahora se calcula el vector centro a extremo final del arco
			if Lista_Linea[::-1][j][2] == 1:
				Vector01_CE = Lista_Linea[::-1][j][6] - Lista_Linea[::-1][j][8]
			else:
				Vector01_CE = Lista_Linea[::-1][j][7] - Lista_Linea[::-1][j][8]
			# ahora se calculan los vectores perpendiculares al extremo final del arco
			Vector01_P1 = App.Vector(-Vector01_CE.y, Vector01_CE.x, 0)
			Vector01_P2 = App.Vector(Vector01_CE.y, -Vector01_CE.x, 0)
			# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
			Normal01_P1 = Vector01_CE.cross(Vector01_P1)
			Normal01_P2 = Vector01_CE.cross(Vector01_P2)
			# ahora calculamos la Normal Unitaria
			Normal01_P1 = Normal01_P1 / Normal01_P1.Length
			Normal01_P2 = Normal01_P2 / Normal01_P2.Length
			# ahora se compara el signo de la Normal Esperada con
			# el signo de la Normal perpendicular,
			# si ambos son iguales significa que el vector perpendicular el es correcto.
			if Normal01_Esperada == Normal01_P1:
				Vector01_P = Vector01_P1
			elif Normal01_Esperada == Normal01_P2:
				Vector01_P = Vector01_P2
			
			# calculamos el vector de la linea
			if Lista_Linea[::-1][Valor_Futuro][2] == 1:
				Vector02 = Lista_Linea[::-1][Valor_Futuro][6] - Lista_Linea[::-1][Valor_Futuro][7]
			else:
				Vector02 = Lista_Linea[::-1][Valor_Futuro][7] - Lista_Linea[::-1][Valor_Futuro][6]
			
			# calculamos el producto cruz entre los vectores tangente del arco y linea
			Vec3 = Vector01_P.cross(Vector02)
			# Ahora sumamos los dos vectores perpendiculares de los arcos
			Vector_T = Vector01_P + Vector02
			# si el producto cruz es igual a cero
			# significa que los extremos de los arcos estan alineados.
			if abs(round(Vec3.Length, 5)) == 0:
				# si ambos vectores se suman y la magnitud es mayor al vector inicial
				# significa que los vectores estan en el mismo sentido.
				if Vector_T.Length > Vector01_P.Length:
					Opcion = 'paralelo'
				else:
					Opcion = 'perpendicular'
			else:
				Opcion = 'perpendicular'
		
		
		# aqui analizamos los vectores de dos arcos
		if Lista_Linea[::-1][j][3] == 'arco' and Lista_Linea[::-1][Valor_Futuro][3] == 'arco':
			# Si el punto inicial esta en la misma ubicacion del angulo inicial 
			# entonces el giro del angulo es en contra de las manecillas del reloj
			# por lo tanto su Normal Esperado es positiva.
			if Lista_Linea[::-1][j][1] == 1:
				Normal01_Esperada = App.Vector(0, 0, 1)
			else:
				Normal01_Esperada = App.Vector(0, 0, -1)
			# ahora se calcula el vector centro a extremo final del arco
			if Lista_Linea[::-1][j][2] == 1:
				Vector01_CE = Lista_Linea[::-1][j][6] - Lista_Linea[::-1][j][8]
			else:
				Vector01_CE = Lista_Linea[::-1][j][7] - Lista_Linea[::-1][j][8]
			# ahora se calculan los vectores perpendiculares al extremo final del arco
			Vector01_P1 = App.Vector(-Vector01_CE.y, Vector01_CE.x, 0)
			Vector01_P2 = App.Vector(Vector01_CE.y, -Vector01_CE.x, 0)
			# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
			Normal01_P1 = Vector01_CE.cross(Vector01_P1)
			Normal01_P2 = Vector01_CE.cross(Vector01_P2)
			# ahora calculamos la Normal Unitaria
			Normal01_P1 = Normal01_P1 / Normal01_P1.Length
			Normal01_P2 = Normal01_P2 / Normal01_P2.Length
			# ahora se compara el signo de la Normal Esperada con
			# el signo de la Normal perpendicular,
			# si ambos son iguales significa que el vector perpendicular el es correcto.
			if Normal01_Esperada == Normal01_P1:
				Vector01_P = Vector01_P1
			elif Normal01_Esperada == Normal01_P2:
				Vector01_P = Vector01_P2
			
			# Si el punto inicial esta en la misma ubicacion del angulo inicial 
			# entonces el giro del angulo es en contra de las manecillas del reloj
			# por lo tanto su Normal Esperado es positiva.
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				Normal02_Esperada = App.Vector(0, 0, 1)
			else:
				Normal02_Esperada = App.Vector(0, 0, -1)
			# ahora se calcula el vector centro a extremo inicial del arco
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				Vector02_CE = Lista_Linea[::-1][Valor_Futuro][6] - Lista_Linea[::-1][Valor_Futuro][8]
			else:
				Vector02_CE = Lista_Linea[::-1][Valor_Futuro][7] - Lista_Linea[::-1][Valor_Futuro][8]
			# ahora se calculan los vectores perpendiculares al extremo inicial del arco
			Vector02_P1 = App.Vector(-Vector02_CE.y, Vector02_CE.x, 0)
			Vector02_P2 = App.Vector(Vector02_CE.y, -Vector02_CE.x, 0)
			# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
			Normal02_P1 = Vector02_CE.cross(Vector02_P1)
			Normal02_P2 = Vector02_CE.cross(Vector02_P2)
			# ahora calculamos la Normal Unitaria
			Normal02_P1 = Normal02_P1 / Normal02_P1.Length
			Normal02_P2 = Normal02_P2 / Normal02_P2.Length
			# ahora se compara el signo de la Normal Esperada con
			# el signo de la Normal perpendicular,
			# si ambos son iguales significa que el vector perpendicular el es correcto.
			if Normal02_Esperada == Normal02_P1:
				Vector02_P = Vector02_P1
			elif Normal02_Esperada == Normal02_P2:
				Vector02_P = Vector02_P2
				
			# calculamos el producto cruz entre los vectores centro de cada arco
			Vec3 = Vector01_CE.cross(Vector02_CE)
			# Ahora sumamos los dos vectores perpendiculares de los arcos
			Vector_T = Vector01_P + Vector02_P
			# si el producto cruz es igual a cero
			# significa que los extremos de los arcos estan alineados.
			if abs(round(Vec3.Length, 5)) == 0:
				# si ambos vectores se suman y la magnitud es mayor al vector inicial
				# significa que los vectores estan en el mismo sentido.
				if Vector_T.Length > Vector01_P.Length:
					Opcion = 'paralelo'
				else:
					Opcion = 'perpendicular'
			else:
				Opcion = 'perpendicular'
			
		
		if Opcion == 'paralelo':
			Boceto_X.addConstraint(Sketcher.Constraint('Tangent', Lista_Linea[::-1][j][0], Lista_Linea[::-1][j][2], Lista_Linea[::-1][Valor_Futuro][0], Lista_Linea[::-1][Valor_Futuro][1]))
		if Opcion == 'perpendicular':
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[::-1][j][0], Lista_Linea[::-1][j][2], Lista_Linea[::-1][Valor_Futuro][0], Lista_Linea[::-1][Valor_Futuro][1]))


def Bloquear_Lineas(Boceto_X, Total_Lista):
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'linea':
			Boceto_X.addConstraint(Sketcher.Constraint('Block', Lista_Linea[::-1][j][0]))


def Bloquear_Arcos(Boceto_X, Total_Lista):
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'arco':
			Boceto_X.addConstraint(Sketcher.Constraint('Block', Lista_Linea[::-1][j][0]))


def Bloquear_Circulos(Boceto_X, Total_Lista):
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'circulo':
			Boceto_X.addConstraint(Sketcher.Constraint('Block', Lista_Linea[::-1][j][0]))


def Fijar_Circulo_Origen(Pt1, Boceto_X, Index_Obj):
	if list(Pt1)[0] >= 0:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', -1,1,Index_Obj,3, abs(list(Pt1)[0])))
	else:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', Index_Obj,3,-1,1, abs(list(Pt1)[0])))
	if list(Pt1)[1] >= 0:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceY', -1,1,Index_Obj,3, abs(list(Pt1)[1])))
	else:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceY', Index_Obj,3,-1,1, abs(list(Pt1)[1])))


def Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	#Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Indice = '', Simetria = False):
	#Crear_Arco(Pt1, Eje, Radio, Boceto_X, Ang_Ini, Ang_Fin, Indice = '', Simetria = False):
	for j in range(0, len(Lista_X)):
		if Lista_X[j][0] == 'linea':
			Crear_Linea(App.Vector(Lista_X[j][2], Lista_X[j][3], 0), App.Vector(Lista_X[j][4], Lista_X[j][5], 0), Boceto_X, '', j)
		if Lista_X[j][0] == 'arco':
			Crear_Arco(App.Vector(Lista_X[j][1], Lista_X[j][2], 0), Lista_X[j][3], Lista_X[j][4], Boceto_X, Lista_X[j][5], Lista_X[j][6], j)
	
	
	if Simetria == False:
		# Bloquear_Lineas(Boceto_X, Total_Lista):
		Bloquear_Lineas(Boceto_X, len(Lista_X))
		
		# Unir_Lineas(Boceto_X, Total_Lista):
		Unir_Lineas(Boceto_X, len(Lista_X))
		
		# Bloquear_Arcos(Boceto_X, Total_Lista):
		Bloquear_Arcos(Boceto_X, len(Lista_X))
		
		
	Plano.recompute()
	
	
	if Simetria == True:
		#$ Objeto Simetrico en el centro
		for k in range(0, len(Lista_X)):
			if Lista_X[::-1][k][0] == 'linea':
				Crear_Linea(App.Vector(-Lista_X[::-1][k][2], Lista_X[::-1][k][3], 0), App.Vector(-Lista_X[::-1][k][4], Lista_X[::-1][k][5], 0), Boceto_X, '', k, True)
			if Lista_X[::-1][k][0] == 'arco':
				Crear_Arco(App.Vector(-Lista_X[::-1][k][1], Lista_X[::-1][k][2], 0), Lista_X[::-1][k][3], Lista_X[::-1][k][4], Boceto_X, math.radians(180) - Lista_X[::-1][k][6], math.radians(180) - Lista_X[::-1][k][5], k, True)

	if Espejo == True:
		#$ Objeto Espejo con respecto al Origen
		for k in range(0, len(Lista_X)):
			if Lista_X[k][0] == 'linea':
				Crear_Linea(App.Vector(-Lista_X[k][2], Lista_X[k][3], 0), App.Vector(-Lista_X[k][4], Lista_X[k][5], 0), Boceto_X, '', k)
			if Lista_X[k][0] == 'arco':
				Crear_Arco(App.Vector(-Lista_X[k][1], Lista_X[k][2], 0), Lista_X[k][3], Lista_X[k][4], Boceto_X, math.radians(180) - Lista_X[k][6], math.radians(180) - Lista_X[k][5], k)
		
	
	Plano.recompute()
	
	
	if Simetria == True:
		# Bloquear_Lineas(Boceto_X, Total_Lista)
		Bloquear_Lineas(Boceto_X, 2 * len(Lista_X))
		
		# Unir_Lineas(Boceto_X, Total_Lista):
		Unir_Lineas(Boceto_X, 2 * len(Lista_X))
		
		# Bloquear_Arcos(Boceto_X, Total_Lista)
		Bloquear_Arcos(Boceto_X, 2 * len(Lista_X))
		
	if Espejo == True:
		# Bloquear_Lineas(Boceto_X, Total_Lista):
		Bloquear_Lineas(Boceto_X, len(Lista_X))
		
		# Unir_Lineas(Boceto_X, Total_Lista):
		Unir_Lineas(Boceto_X, len(Lista_X))
		
		# Bloquear_Arcos(Boceto_X, Total_Lista):
		Bloquear_Arcos(Boceto_X, len(Lista_X))
	
	
	Plano.recompute()


def Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, Separacion = 76):
	
	Separacion = Separacion / 2
	Val_X = (Largo_Total / 2) + 1 + 14 / 2
	Val_Y = (Alto_Total / 2) + 1 + 14 / 2
	Delta_X = (Largo_Total - 2 * Radio_Pral) / 2
	Delta_Y = (Alto_Total - 2 * Radio_Pral) / 2
	Multi_X = math.floor(Delta_X / Separacion)
	Multi_Y = math.floor(Delta_Y / Separacion)
	
	if Multi_X == 0:
		DeltaVal_X = [Delta_X]
	elif Multi_X == 1:
		DeltaVal_X = [Separacion]
	else:
		Multi_X = math.floor((Delta_X - Separacion) / (Separacion * 2))
		DeltaVal_X = [Separacion]
		Ciclo = Separacion
		for k in range(Multi_X):
			Ciclo += Separacion * 2
			DeltaVal_X.append(Ciclo)
		if math.floor(((Delta_X - Separacion) - Separacion * 2 * Multi_X) / Separacion) >= 1:
			DeltaVal_X.append(Delta_X)
			
	if Multi_Y == 0:
		DeltaVal_Y = [Delta_Y]
	elif Multi_Y == 1:
		DeltaVal_Y = [Separacion]
	else:
		Multi_Y = math.floor((Delta_Y - Separacion) / (Separacion * 2))
		DeltaVal_Y = [Separacion]
		Ciclo = Separacion
		for k in range(Multi_Y):
			Ciclo += Separacion * 2
			DeltaVal_Y.append(Ciclo)
		if math.floor(((Delta_Y - Separacion) - Separacion * 2 * Multi_Y) / Separacion) >= 1:
			DeltaVal_Y.append(Delta_Y)
	
	
	# Actualizar_Lista02(Val_X, Val_Y):
	Lista02 = Actualizar_Lista02(Val_X, Val_Y)
		
	# Actualizar_Lista03(Lista02, DeltaVal_X, DeltaVal_Y, Radio_Agujero):
	Lista03 = Actualizar_Lista03(Lista02, DeltaVal_X, DeltaVal_Y, Radio_Agujero)
	
	
	for k in range(0, len(Lista03)):
		# Crear_Circulo(Pt1, Eje, Radio, Boceto_X):
		Crear_Circulo(Lista03[k][0], Lista03[k][1], Lista03[k][2], Boceto_X)
	
	# Bloquear_Circulos(Boceto_X, Total_Lista):
	Bloquear_Circulos(Boceto_X, len(Lista03))


def Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	
	# Contorno circular
	Lista01 = [
		['linea', 'Horizontal', -(Largo_X - 2 * Radio_X) / 2, Alto_X / 2, (Largo_X - 2 * Radio_X) / 2, Alto_X / 2],
		['arco', (Largo_X - 2 * Radio_X) / 2, (Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(0), math.radians(90)],
		['linea', 'Vertical', Largo_X / 2, (Alto_X - 2 * Radio_X) / 2, Largo_X / 2, -(Alto_X - 2 * Radio_X) / 2],
		['arco', (Largo_X - 2 * Radio_X) / 2, -(Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(270), math.radians(360)],
		['linea', 'Horizontal', (Largo_X - 2 * Radio_X) / 2, -Alto_X / 2, -(Largo_X - 2 * Radio_X) / 2, -Alto_X / 2],
		['arco', -(Largo_X - 2 * Radio_X) / 2, -(Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(180), math.radians(270)],
		['linea', 'Vertical', -Largo_X / 2, -(Alto_X - 2 * Radio_X) / 2, -Largo_X / 2, (Alto_X - 2 * Radio_X) / 2],
		['arco', -(Largo_X - 2 * Radio_X) / 2, (Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(90), math.radians(180)]
	]
	return Lista01


def Actualizar_Lista02(Val_X, Val_Y):
	
	# Ubicacion de los agujeros
	Lista02 = [
	['Arriba',     1, Val_Y, 'Derecha',    1],
	['Derecha',    1, Val_X, 'Arriba',     1],
	['Derecha',    1, Val_X, 'Abajo',     -1],
	['Abajo',     -1, Val_Y, 'Derecha',    1],
	['Abajo',     -1, Val_Y, 'Izquierda', -1],
	['Izquierda', -1, Val_X, 'Abajo',     -1],
	['Izquierda', -1, Val_X, 'Arriba',     1],
	['Arriba',     1, Val_Y, 'Izquierda', -1]
	]
	
	return Lista02
	
	
def Actualizar_Lista03(Lista02, DeltaVal_X, DeltaVal_Y, Radio_Agujero):
	
	# Ubicacion de lo agujeros con vectores
	Lista03 = []
	for j in range(0, len(Lista02)):
		if Lista02[j][0] == 'Arriba':
			for k in range(0, len(DeltaVal_X)):
				Lista_Temp = [App.Vector(Lista02[j][4] * DeltaVal_X[k], Lista02[j][1] * Lista02[j][2], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Abajo':
			for k in range(0, len(DeltaVal_X)):
				Lista_Temp = [App.Vector(Lista02[j][4] * DeltaVal_X[k], Lista02[j][1] * Lista02[j][2], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Derecha':
			for k in range(0, len(DeltaVal_Y)):
				Lista_Temp = [App.Vector(Lista02[j][1] * Lista02[j][2],Lista02[j][4] * DeltaVal_Y[k], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Izquierda':
			for k in range(0, len(DeltaVal_Y)):
				Lista_Temp = [App.Vector(Lista02[j][1] * Lista02[j][2],Lista02[j][4] * DeltaVal_Y[k], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
	
	return Lista03
	
	
	
def Limpiar_Pantalla():
	mw = Gui.getMainWindow()
	rv = mw.findChild(QtGui.QTextEdit, "Report view")
	rv.clear()
	
	pc = mw.findChild(QtGui.QPlainTextEdit,"Python console")
	pc.onClearConsole()
	



#! crear Boceto Cuerpo
def Crear_Boceto_Cuerpo(Largo_Total, Alto_Total, Radio_Pral):
	
	Largo_Y = Largo_Total
	Alto_Y = Alto_Total
	Radio_Y = Radio_Pral
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista01, Boceto_LVS_C)
	
	
	Largo_Y += 1 + 1
	Alto_Y += 1 + 1
	Radio_Y += 1
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista01, Boceto_LVS_C)
	
	
	Largo_Y += 14 + 14
	Alto_Y += 14 + 14
	Radio_Y += 14
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista01, Boceto_LVS_C)
	
	
	Largo_Y += 1 + 1
	Alto_Y += 1 + 1
	Radio_Y += 1
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista01, Boceto_LVS_C)
	# Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, Separacion = 76):
	Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_LVS_C, 1.5)
	


#! crear Boceto Tapadera
def Crear_Boceto_Tapadera(Largo_Total, Alto_Total, Radio_Pral):
	
	Largo_Y = Largo_Total
	Alto_Y = Alto_Total
	Radio_Y = Radio_Pral
	
	Largo_Y += 1.5 + 1.5
	Alto_Y += 1.5 + 1.5
	Radio_Y += 1.5
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista01, Boceto_LVS_T)
	
	
	Largo_Y += 13 + 13
	Alto_Y += 13 + 13
	Radio_Y += 13
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista01, Boceto_LVS_T)
	# Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, Separacion = 76):
	Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_LVS_T, 1.5)
	
	

#! crear Boceto Pieza 1
def Crear_Boceto_P1(Largo_Total, Alto_Total, Radio_Pral):

	Origen_Y = -(Alto_Total / 2) - 15
	Origen_X = 0
	
	if ((Largo_Total - 2 * Radio_Pral) / 2) >= 33:
	
		Lista04 = [
		['linea', 'Horizontal', Origen_X, Origen_Y, Origen_X + 33, Origen_Y],
		['linea', 'Vertical', Origen_X + 33, Origen_Y, Origen_X + 33, Origen_Y - 1],
		['arco', Origen_X + 33, Origen_Y - 6, App.Vector(0, 0, 1), 5, math.radians(90), math.radians(180)],
		['linea', 'Vertical', Origen_X + 28, Origen_Y - 6, Origen_X + 28, Origen_Y - 16],
		['arco', Origen_X + 23, Origen_Y - 16, App.Vector(0, 0, 1), 5, math.radians(270), math.radians(360)],
		['linea', 'Horizontal', Origen_X + 23, Origen_Y - 21, Origen_X, Origen_Y - 21]
		]
	
	else:
		
		Desfase_X = 33 - (Largo_Total - 2 * Radio_Pral) / 2
		Radio_CC = Radio_Pral + (1 + 14 + 1) + 5
		Desfase_Y = Radio_CC - math.sqrt(Radio_CC**2 - Desfase_X**2)
		Angulo_Desfase = math.acos(Desfase_X / Radio_CC)
		
		Lista04 = [
		['linea', 'Horizontal', Origen_X, Origen_Y - 21, Origen_X + 23, Origen_Y - 21],
		['arco', Origen_X + 23, Origen_Y - 16, App.Vector(0, 0, 1), 5, math.radians(270), math.radians(360)],
		['linea', 'Vertical', Origen_X + 28, Origen_Y - 16, Origen_X + 28, Origen_Y - 6 + Desfase_Y],
		['arco', Origen_X + 33, Origen_Y - 6 + Desfase_Y, App.Vector(0, 0, 1), 5, math.radians(180) - Angulo_Desfase, math.radians(180)],
		['linea', 'Oblicua', Origen_X + 33 - 5 * math.cos(Angulo_Desfase), Origen_Y - 6 + Desfase_Y + 5 * math.sin(Angulo_Desfase), Origen_X + 33 - 6 * math.cos(Angulo_Desfase), Origen_Y - 6 + Desfase_Y + 6 * math.sin(Angulo_Desfase)],
		['arco', (Largo_Total - 2 * Radio_Pral) / 2, -(Alto_Total - 2 * Radio_Pral) / 2, App.Vector(0, 0, 1), Radio_CC - 6, math.radians(270), math.radians(360) - Angulo_Desfase],
		['linea', 'Horizontal', (Largo_Total - 2 * Radio_Pral) / 2, Origen_Y, Origen_X, Origen_Y]
		]
		
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista04, Boceto_LVS_P1, True)
	
	
	
	#$ crear Boceto Hoyo Pieza 1
	Lista05 = [
	['linea', 'Horizontal', Origen_X + 2, Origen_Y - 11, Origen_X + 25, Origen_Y - 11],
	['arco', Origen_X + 25, Origen_Y - 12, App.Vector(0, 0, 1), 1, math.radians(0), math.radians(90)],
	['linea', 'Vertical', Origen_X + 26, Origen_Y - 12, Origen_X + 26, Origen_Y - 16],
	['arco', Origen_X + 23, Origen_Y - 16, App.Vector(0, 0, 1), 3, math.radians(270), math.radians(360)],
	['linea', 'Horizontal', Origen_X + 23, Origen_Y - 19, Origen_X + 2, Origen_Y - 19],
	['arco', Origen_X + 2, Origen_Y - 18, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
	['linea', 'Vertical', Origen_X + 1, Origen_Y - 18, Origen_X + 1, Origen_Y - 12],
	['arco', Origen_X + 2, Origen_Y - 12, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista05, Boceto_LVS_H_P1, False, True)
	
	
	Lista06 = [
	['linea', 'Horizontal', Origen_X + 2, Origen_Y - 1, Origen_X + 33 - 4 * math.sqrt(3), Origen_Y - 1],
	['arco', Origen_X + 33 - 4 * math.sqrt(3), Origen_Y - 2, App.Vector(0, 0, 1), 1, math.radians(-30), math.radians(90)],
	['arco', Origen_X + 33, Origen_Y - 6, App.Vector(0, 0, 1), 7, math.radians(150), math.radians(180)],
	['linea', 'Vertical', Origen_X + 26, Origen_Y - 6, Origen_X + 26, Origen_Y - 8],
	['arco', Origen_X + 25, Origen_Y - 8, App.Vector(0, 0, 1), 1, math.radians(270), math.radians(360)],
	['linea', 'Horizontal', Origen_X + 25, Origen_Y - 9, Origen_X + 2, Origen_Y - 9],
	['arco', Origen_X + 2, Origen_Y - 8, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
	['linea', 'Vertical', Origen_X + 1, Origen_Y - 8, Origen_X + 1, Origen_Y - 2],
	['arco', Origen_X + 2, Origen_Y - 2, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista06, Boceto_LVS_H_P1, False, True)
	
	

#! crear Boceto Pieza 2
def Crear_Boceto_P2(Largo_Total, Alto_Total, Radio_Pral):

	Origen_Y = (Alto_Total / 2) + 15
	Origen_X = 0
	
	if ((Largo_Total - 2 * Radio_Pral) / 2) > 45:
	
		Lista07 = [
		['linea', 'Horizontal', Origen_X, Origen_Y + 7, Origen_X + 41, Origen_Y + 7],
		['arco', Origen_X + 41, Origen_Y + 5, App.Vector(0, 0, 1), 2, math.radians(0), math.radians(90)],
		['linea', 'Vertical', Origen_X + 43, Origen_Y + 5, Origen_X + 43, Origen_Y + 3],
		['arco', Origen_X + 45, Origen_Y + 3, App.Vector(0, 0, 1), 2, math.radians(180), math.radians(270)],
		['linea', 'Vertical', Origen_X + 45, Origen_Y + 1, Origen_X + 45, Origen_Y],
		['linea', 'Horizontal', Origen_X + 45, Origen_Y, Origen_X, Origen_Y]
		]
		
	else:
		
		Desfase_X = 45 - (Largo_Total - 2 * Radio_Pral) / 2
		Radio_CC = Radio_Pral + (1 + 14 + 1) + 2
		Desfase_Y = Radio_CC - math.sqrt(Radio_CC**2 - Desfase_X**2)
		Angulo_Desfase = math.acos(Desfase_X / Radio_CC)
		
		Lista07 = [
		['linea', 'Horizontal', Origen_X, Origen_Y + 7, Origen_X + 41, Origen_Y + 7],
		['arco', Origen_X + 41, Origen_Y + 5, App.Vector(0, 0, 1), 2, math.radians(0), math.radians(90)],
		['linea', 'Vertical', Origen_X + 43, Origen_Y + 5, Origen_X + 43, Origen_Y + 3 - Desfase_Y],
		['arco', Origen_X + 45, Origen_Y + 3 - Desfase_Y, App.Vector(0, 0, 1), 2, math.radians(180), math.radians(180) + Angulo_Desfase],
		['linea', 'Oblicua', Origen_X + 45 - 2 * math.cos(Angulo_Desfase), Origen_Y + 3 - Desfase_Y - 2 * math.sin(Angulo_Desfase), Origen_X + 45 - 3 * math.cos(Angulo_Desfase), Origen_Y + 3 - Desfase_Y - 3 * math.sin(Angulo_Desfase)],
		['arco', (Largo_Total - 2 * Radio_Pral) / 2, (Alto_Total - 2 * Radio_Pral) / 2, App.Vector(0, 0, 1), Radio_CC - 3, Angulo_Desfase, math.radians(90)],
		['linea', 'Horizontal', (Largo_Total - 2 * Radio_Pral) / 2, Origen_Y, Origen_X, Origen_Y]
		]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista07, Boceto_LVS_P2, True)
	
	
	
	#$ crear Boceto Hoyo Pieza 2
	Lista08 = [
	['linea', 'Horizontal', Origen_X + 2, Origen_Y + 5, Origen_X + 35, Origen_Y + 5],
	['arco', Origen_X + 2, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)],
	['linea', 'Vertical', Origen_X + 1, Origen_Y + 4, Origen_X + 1, Origen_Y + 2],
	['arco', Origen_X + 2, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
	['linea', 'Horizontal', Origen_X + 2, Origen_Y + 1, Origen_X + 35, Origen_Y + 1],
	['arco', Origen_X + 35, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(270), math.radians(360)],
	['linea', 'Vertical', Origen_X + 36, Origen_Y + 2, Origen_X + 36, Origen_Y + 4],
	['arco', Origen_X + 35, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(0), math.radians(90)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista08, Boceto_LVS_H_P2, False, True)
	
	
	Lista09 = [
	['linea', 'Horizontal', Origen_X + 39, Origen_Y + 5, Origen_X + 40, Origen_Y + 5],
	['arco', Origen_X + 39, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)],
	['linea', 'Vertical', Origen_X + 38, Origen_Y + 4, Origen_X + 38, Origen_Y + 2],
	['arco', Origen_X + 39, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
	['linea', 'Horizontal', Origen_X + 39, Origen_Y + 1, Origen_X + 40, Origen_Y + 1],
	['arco', Origen_X + 40, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(270), math.radians(360)],
	['linea', 'Vertical', Origen_X + 41, Origen_Y + 2, Origen_X + 41, Origen_Y + 4],
	['arco', Origen_X + 40, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(0), math.radians(90)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False):
	Crear_Contorno(Lista09, Boceto_LVS_H_P2, False, True)
	


#! Crear_Boceto_Iman
def Crear_Boceto_Iman(Largo_Total, Alto_Total, Radio_Pral):
	
	Lista10 = [
	[App.Vector(0, (Alto_Total / 2) + 1 + 14 / 2, 0), App.Vector(0, 0, 1), 7],
	[App.Vector((Largo_Total / 2) + 1 + 14 / 2, 0, 0), App.Vector(0, 0, 1), 7],
	[App.Vector(0, -(Alto_Total / 2) - 1 - 14 / 2, 0), App.Vector(0, 0, 1), 7],
	[App.Vector(-(Largo_Total / 2) - 1 - 14 / 2, 0, 0), App.Vector(0, 0, 1), 7]
	]
	
	for k in range(0, len(Lista10)):
		# Crear_Circulo(Pt1, Eje, Radio, Boceto_X):
		Crear_Circulo(Lista10[k][0], Lista10[k][1], Lista10[k][2], Boceto_LVS_I)
	
	# Bloquear_Circulos(Boceto_X, Total_Lista):
	Bloquear_Circulos(Boceto_LVS_I, len(Lista10))



#! Estas son las funciones para las partes que forman el Hoop
def Crear_Hoop(Largo_Total = '156 mm', Alto_Total = '156 mm', Radio_Pral = '35 mm'):
	
	# aqui convertimos el texto a numero con las unidades por defecto en FreeCAD
	LT = App.Units.Quantity(Largo_Total).Value
	AT = App.Units.Quantity(Alto_Total).Value
	RP = App.Units.Quantity(Radio_Pral).Value
	
	# Limpiar_Pantalla():
	Limpiar_Pantalla()
	
	# Crear_Contenedor_2D():
	Crear_Contenedor_2D()
	
	# Crear_Boceto_Cuerpo(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_Cuerpo(LT, AT, RP)
	
	# Crear_Boceto_Tapadera(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_Tapadera(LT, AT, RP)
	
	# Crear_Boceto_P1(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_P1(LT, AT, RP)
	
	# Crear_Boceto_P2(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_P2(LT, AT, RP)
	
	# Crear_Boceto_Iman(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_Iman(LT, AT, RP)




#! Variable Global
#$ Esta es la memoria de los Objetos 2D para revision y analisis
Lista_Linea = []




#! Esta es la funcion que inicia la Macro
# Crear_Hoop(Largo_Total, Alto_Total, Radio_Pral):
Crear_Hoop('156 mm', '156 mm', '35 mm')

# '156 mm', '156 mm', '35 mm'
# '294 mm', '212 mm', '35 mm'


App.Console.PrintMessage(f'Fin de la {Pieza_H1.Label}\n')


'''
#Ejemplo mover la pieza usando una ventana flotante
from PySide import QtGui
val = QtGui.QInputDialog.getText(None, 'Mover Objeto', 'Ingrese los valores \n separados por coma. \n Ejemplo: 100,0,0')[0]
myVal = tuple(val.split(','))
Pieza_H1.Placement.Base = App.Vector(myVal)
'''








'''

print(len(Lista_Linea))
for l in Lista_Linea:
	print(l)

'''


# Macro End: C:\Users\OWNER\AppData\Roaming\FreeCAD\Macro\Hoop_1.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
