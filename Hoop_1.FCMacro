# -*- coding: utf-8 -*-

'''
############################################################################
#                                                                          #
#                                                                          #
#   Copyright (c) 2024                                                     #
#   Original code by:                                                      #
#                       :::====   :::=====  :::====                        #
#                       :::  ===  :::       :::  ===                       #
#                       ========  ======    ===  ===                       #
#                       ===  ===  ===       ===  ===                       #
#                       ===  ===  ===       =======                        #
#                                                                          #
#   This program is free software, you can redistribute it and/or modify   #
#   it under the terms of the GNU Lesser General Public Licence ( LGPL )   #
#   as published by the Free Software Fundation;  either  version  2  of   #
#   the Licence, or (at your option) any later version.                    #
#   for detail see the LICENCE text file.                                  #
#                                                                          #
#   This software is distributed in the hope that  it  will  be  useful,   #
#   but WITHOUT ANY WARRANTY,  without  even  the  implied  warranty  of   #
#   MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   #
#   GNU Library General Public Licence for more details.                   #
#                                                                          #
#   You should have received a copy of the GNU  Library  General  Public   #
#   Licence along with this macro,  if not, write to the  Free  Software   #
#   Foundation Inc., 59 Temple Place, Suite 330,  Boston,  MA 02111-1307   #
#   USA.                                                                   #
#                                                                          #
#                                                                          #
############################################################################
'''

# Macro Begin: C:\Users\OWNER\AppData\Roaming\FreeCAD\Macro\Hoop_1.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++

from PySide import QtGui
import FreeCADGui as Gui
import FreeCAD as App
import pandas as pd
import PartDesignGui
import PartDesign
import Sketcher
import Part
import math
import datetime
import time



#! Estos son las funciones para las Piezas, Cuerpos, Grupos, Bocetos
def Crear_Plano():
	
	# Tomamos el archivo activo
	global Plano
	Plano = App.activeDocument()


def Crear_Grupo(Titulo, Etiqueta = '', Objeto_X = False):
	
	# Validamos los argumentos de la funcion
	if not type(Titulo) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Grupo \n\t {type(Titulo) = }')
	
	if not type(Etiqueta) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Grupo \n\t {type(Etiqueta) = }')
	
	if not str(type(Objeto_X)) in ("<class 'App.Part'>", "<class 'bool'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Part \n\t Funcion = Crear_Grupo \n\t {type(Objeto_X) = }')
	
	
	Grupo_X = Plano.addObject('App::DocumentObjectGroup', Titulo)
	Plano.Tip = Grupo_X
	if Etiqueta == '':
		Grupo_X.Label = Titulo
	else:
		Grupo_X.Label = Etiqueta
	if Objeto_X == False:
		Plano.Tip = Grupo_X
	else:
		Objeto_X.addObject(Grupo_X)
	Plano.recompute()
	return Grupo_X


def Crear_Pieza():
	
	Crear_Plano()
	Pieza_X = Plano.addObject('App::Part','Part_H001')
	Plano.Tip = Pieza_X
	Pieza_X.Label = 'Pieza_H001'
	Plano.recompute()
	return Pieza_X


def Crear_Cuerpo(Titulo, Etiqueta = '', Objeto_X = False):
	
	# Validamos los argumentos de la funcion
	if not type(Titulo) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Cuerpo \n\t {type(Titulo) = }')
		
	if not type(Etiqueta) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Cuerpo \n\t {type(Etiqueta) = }')
		
	if not str(type(Objeto_X)) in ("<class 'App.DocumentObjectGroup'>", "<class 'App.Part'>", "<class 'bool'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Group o Part \n\t Funcion = Crear_Cuerpo \n\t {type(Objeto_X) = }')
	
	
	Cuerpo_X = Plano.addObject('PartDesign::Body', Titulo)
	if Etiqueta == '':
		Cuerpo_X.Label = Titulo
	else:
		Cuerpo_X.Label = Etiqueta
	if Objeto_X == False:
		Plano.Tip = Cuerpo_X
	else:
		Objeto_X.addObject(Cuerpo_X)
	Plano.recompute()
	return Cuerpo_X


def Crear_Boceto(Titulo, Etiqueta = '', Objeto_X = False, Plano_X = ''):
	
	# Validamos los argumentos de la funcion
	if not type(Titulo) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Boceto \n\t {type(Titulo) = }')
		
	if not type(Etiqueta) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Boceto \n\t {type(Etiqueta) = }')
		
	if not str(type(Objeto_X)) in ("<class 'PartDesign.Body'>", "<class 'bool'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Body \n\t Funcion = Crear_Boceto \n\t {type(Objeto_X) = }')
		
	if not type(Plano_X) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Boceto \n\t {type(Plano_X) = }')
	
	
	Boceto_X = Plano.addObject('Sketcher::SketchObject', Titulo)
	Plano.Tip = Boceto_X
	if Plano_X == '':
		Plano_X = 'XY_Plane'
	if Etiqueta == '':
		Boceto_X.Label = Titulo
	else:
		Boceto_X.Label = Etiqueta
	Boceto_X.MapMode = 'FlatFace'
	if Objeto_X == False:
		Plano.Tip = Boceto_X
		Cuerpo_New = Crear_Cuerpo('New_Body', '', Pieza_H1)
		Cuerpo_New.addObject(Boceto_X)
		for k in Cuerpo_New.Origin.OriginFeatures:
			if k.Role == Plano_X:
				XY_Plano = k
		Boceto_X.AttachmentSupport = (XY_Plano, [''])
		del XY_Plano
	else:
		Objeto_X.addObject(Boceto_X)
		for k in Objeto_X.Origin.OriginFeatures:
			if k.Role == Plano_X:
				XY_Plano = k
		Boceto_X.AttachmentSupport = (XY_Plano, [''])
		del XY_Plano
	Plano.recompute()
	return Boceto_X	


def Crear_Variables(Titulo, Etiqueta = '', Objeto_X = False, LT = 156, AT = 156, RT = 35):
	
	# creamos las variables del objeto
	Var_X = Plano.addObject("App::VarSet", Titulo)
	Var_X.Label = Etiqueta
	Objeto_X.addObject(Var_X)
	Var_X.addProperty("App::PropertyLength", "Aro_Largo",     group="Grupo_2D_Aro",    doc="Esta propiedad modifica el Largo del Aro")
	Var_X.Aro_Largo = LT
	Var_X.addProperty("App::PropertyLength", "Aro_Alto",      group="Grupo_2D_Aro",    doc="Esta propiedad modifica el Alto del Aro")
	Var_X.Aro_Alto = AT
	Var_X.addProperty("App::PropertyLength", "Aro_Radio",     group="Grupo_2D_Aro",    doc="Esta propiedad modifica el Radio interior del Aro")
	Var_X.Aro_Radio = RT
	Var_X.addProperty("App::PropertyLength", "Radio_Agujero", group="Grupo_2D_Radio",  doc="Esta propiedad modifica el Radio del Agujero")
	Var_X.Radio_Agujero = "1.5 mm"
	Var_X.addProperty("App::PropertyLength", "Radio_Iman",    group="Grupo_2D_Radio",  doc="Esta propiedad modifica el Radio del Iman")
	Var_X.Radio_Iman = "7 mm"
	Var_X.addProperty("App::PropertyLength", "Aro_Grosor",    group="Grupo_2D_Grosor", doc="Esta propiedad modifica el Grosor del Aro")
	Var_X.Aro_Grosor = "14 mm"
	Var_X.addProperty("App::PropertyLength", "Tap_Grosor",    group="Grupo_2D_Grosor", doc="Esta propiedad modifica el Grosor de la Tapadera")
	Var_X.Tap_Grosor = "13 mm"
	Var_X.addProperty("App::PropertyLength", "Aro_Margen",    group="Grupo_2D_Grosor", doc="Esta propiedad modifica el Margen del Aro")
	Var_X.Aro_Margen = "1 mm"
	Plano.recompute()
	return Var_X


#! Estos son los planos en 2D
def Crear_Contenedor_2D(LT, AT, RT):
	
	### Begin command Std_Part
	global Pieza_H1
	Pieza_H1 = Crear_Pieza()
	
	global Variable_H1
	### Begin command Var_Set
	Variable_H1 = Crear_Variables('VarSet001', 'Variables', Pieza_H1, LT, AT, RT)
	
	### Begin command Std_Group
	global Grupo_LH1
	Grupo_LH1 = Crear_Grupo('Group_LH001', 'Grupo_2D', Pieza_H1)
	
	
	### Begin command PartDesign_Body
	global Cuerpo_LH1
	Cuerpo_LH1 = Crear_Cuerpo('Body_LH001', 'Cuerpo_Layout', Grupo_LH1)
	
	
	### Begin command PartDesign_Sketch
	global Boceto_LVS_C
	Boceto_LVS_C = Crear_Boceto('Sketch_LVS_C001', 'B_LVS_Cuerpo', Cuerpo_LH1)
	global Boceto_LVS_T
	Boceto_LVS_T = Crear_Boceto('Sketch_LVS_T001', 'B_LVS_Tapadera', Cuerpo_LH1)
	global Boceto_LVS_P1
	Boceto_LVS_P1 = Crear_Boceto('Sketch_LVS_P1001', 'B_LVS_Pieza1', Cuerpo_LH1)
	global Boceto_LVS_H_P1
	Boceto_LVS_H_P1 = Crear_Boceto('Sketch_LVS_H_P1001', 'B_LVS_Hoyo_P1', Cuerpo_LH1)
	global Boceto_LVS_P2
	Boceto_LVS_P2 = Crear_Boceto('Sketch_LVS_P2001', 'B_LVS_Pieza2', Cuerpo_LH1)
	global Boceto_LVS_H_P2
	Boceto_LVS_H_P2 = Crear_Boceto('Sketch_LVS_H_P2001', 'B_LVS_Hoyo_P2', Cuerpo_LH1)
	global Boceto_LVS_I
	Boceto_LVS_I = Crear_Boceto('Sketch_LVS_I001', 'B_LVS_Iman', Cuerpo_LH1)
	
	
	
	#! Estos son los planos en 3D
	
	### Begin command PartDesign_Body
	global Cuerpo_H1
	Cuerpo_H1 = Crear_Cuerpo('Body_H001', '', Pieza_H1)
	
	
	### Begin command PartDesign_Sketch
	global Boceto_H1
	Boceto_H1 = Crear_Boceto('Sketch_H001', '', Cuerpo_H1)
	
	
	
def Imprimir_Lista(Lista_X, Nom_Lista = 'Lista X'):
	
	pd.set_option('display.max_columns', None)
	pd.set_option('display.max_rows', None)
	pd.set_option('display.width', 150)
	df = pd.DataFrame(Lista_X)
	
	if Nom_Lista == 'Lista_Linea':
		df[5] = df[5].apply(lambda x : str(round(x, 3)).rstrip('0').rstrip('.'))
		df[6] = df[6].apply(lambda x : [ str(float(round(n, 3))).rstrip('0').rstrip('.').center(3) for n in x ])
		df[7] = df[7].apply(lambda x : [ str(float(round(n, 3))).rstrip('0').rstrip('.').center(3) for n in x ])
		df[8] = df[8].apply(lambda x : [ str(float(round(n, 3))).rstrip('0').rstrip('.').center(3) for n in x ])
		
	if Nom_Lista == 'Lista_Restriccion':
		df[6] = df[6].apply(lambda x : str(round(x, 3)).rstrip('0').rstrip('.').center(3))
	
	print(f'{Nom_Lista} = {len(Lista_X)}')
	print(df)
	
	print()
	
	
def Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, 
							Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
	
	Lista_Restriccion.append([ID])
	Lista_Restriccion[-1].append(Nom_Obj)
	Lista_Restriccion[-1].append(Obj01_ID)
	Lista_Restriccion[-1].append(P01)
	Lista_Restriccion[-1].append(Obj02_ID)
	Lista_Restriccion[-1].append(P02)
	Lista_Restriccion[-1].append(Magnitud)
	Lista_Restriccion[-1].append(Nom_Restr)
	Lista_Restriccion[-1].append(Gr01)
	Lista_Restriccion[-1].append(Gr02)
	Lista_Restriccion[-1].append(Nom_Cont)
	
	
def Seleccionar_Objeto(Boceto_X):
	
	# se usa para seleccionar un objeto
	Gui.Selection.addSelection(Boceto_X)
	
	
#! Estos son las funciones para crear Lineas, Arcos, Circulos
def Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
	
	# Validamos los argumentos de la funcion
	if not type(Pt1) is list:
		raise TypeError(f'\n\n\t Mensaje = No es Lista \n\t Funcion = Crear_Linea \n\t {type(Pt1) = }')
	
	if not type(Pt2) is list:
		raise TypeError(f'\n\n\t Mensaje = No es Lista \n\t Funcion = Crear_Linea \n\t {type(Pt2) = }')
	
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Linea \n\t {type(Boceto_X) = }')
	
	if not type(Restriccion_X) is str:
		raise TypeError(f'\n\n\t Mensaje = No es Texto \n\t Funcion = Crear_Linea \n\t {type(Restriccion_X) = }')
	
	if not type(Simetria) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Linea \n\t {type(Simetria) = }')
	
	
	# aqui guardamos el ID de la linea.
	Lista_Linea.append(list(Boceto_X.addGeometry([Part.LineSegment(App.Vector(Pt1), App.Vector(Pt2))], Guia)))
	# aqui creamos la restriccion Horizontal o Vertical de la linea.
	if Restriccion_X != '':
		Boceto_X.addConstraint(Sketcher.Constraint(Restriccion_X, Lista_Linea[-1][0]))
	# aqui redondeamos los valores numericos de los vectores
	Pt1_Temp = [round(Pt1[0], 10), round(Pt1[1], 10), round(Pt1[2], 10)]
	Pt2_Temp = [round(Pt2[0], 10), round(Pt2[1], 10), round(Pt2[2], 10)]
	# aqui guardamos el punto inicial: Pt1 => (1) y punto final: Pt2 => (2) de la linea.
	Lista_Linea[-1].append(1)
	Lista_Linea[-1].append(2)
	# aqui guardamos el nombre de la linea.
	Lista_Linea[-1].append('linea')
	# aqui guardamos el Boceto que contiene la linea.
	Lista_Linea[-1].append(Boceto_X.Label)
	# aqui guardamos la magnitud de la linea.
	Pt3 = App.Vector(Pt2) - App.Vector(Pt1)
	Lista_Linea[-1].append(round(Pt3.Length, 10))
	# aqui guardamos el punto inicial de la linea.
	Lista_Linea[-1].append(Pt1_Temp)
	# aqui guardamos el punto final de la linea.
	Lista_Linea[-1].append(Pt2_Temp)
	# aqui guardamos el punto centro => N/A.
	Lista_Linea[-1].append([0.0, 0.0, 0.0])
	# aqui guardamos el grupo al que pertenece
	Lista_Linea[-1].append(Grupo_X)
	
	
def Crear_Arco(Pt1, Eje, Radio, Boceto_X, Ang_Ini, Ang_Fin, Simetria = False, Restriccion = False, Grupo_X = 'G_001', Guia = False):
	
	# Validamos los argumentos de la funcion
	if not str(type(Pt1)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Arco \n\t {type(Pt1) = }')
		
	if not str(type(Eje)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Arco \n\t {type(Eje) = }')
		
	if not type(Radio) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Arco \n\t {type(Radio) = }')
	
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Arco \n\t {type(Boceto_X) = }')
		
	if not type(Ang_Ini) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Arco \n\t {type(Ang_Ini) = }')
		
	if not type(Ang_Fin) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Arco \n\t {type(Ang_Fin) = }')
		
	if not type(Simetria) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Arco \n\t {type(Simetria) = }')
	
	
	# aqui guardamos el ID del arco.
	Lista_Linea.append(list(Boceto_X.addGeometry([Part.ArcOfCircle(Part.Circle(Pt1, Eje , Radio), Ang_Ini, Ang_Fin)], Guia)))
	if Restriccion == True:
		# aqui creamos la restriccion Radio del arco.
		Boceto_X.addConstraint(Sketcher.Constraint('Radius', Lista_Linea[-1][0], Radio))
	# aqui creamos los puntos de los extremos del arco con los valores numericos redondeados
	Pt1_Temp = App.Vector(round(Pt1.x + Radio * math.cos(Ang_Ini), 10), round(Pt1.y + Radio * math.sin(Ang_Ini), 10), round(Pt1.z, 10))
	Pt2_Temp = App.Vector(round(Pt1.x + Radio * math.cos(Ang_Fin), 10), round(Pt1.y + Radio * math.sin(Ang_Fin), 10), round(Pt1.z, 10))
	Eje_Temp = App.Vector(round(Pt1.x, 10), round(Pt1.y, 10), round(Pt1.z, 10))
	# aqui guardamos el punto inicial: Pt1_Temp => (1) y punto final: Pt2_Temp => (2) del arco.
	Lista_Linea[-1].append(1)
	Lista_Linea[-1].append(2)
	# aqui guardamos el nombre del arco.
	Lista_Linea[-1].append('arco')
	# aqui guardamos el Boceto que contiene al arco.
	Lista_Linea[-1].append(Boceto_X.Label)
	# aqui guardamos el radio del arco.
	Lista_Linea[-1].append(round(Radio, 10))
	# aqui guardamos el punto inicial del arco.
	Lista_Linea[-1].append(list(Pt1_Temp))
	# aqui guardamos el punto final del arco.
	Lista_Linea[-1].append(list(Pt2_Temp))
	# aqui guardamos el punto central del arco.
	Lista_Linea[-1].append(list(Eje_Temp))
	# aqui guardamos el grupo al que pertenece
	Lista_Linea[-1].append(Grupo_X)
	

def Crear_Circulo(Pt1, Eje, Radio, Boceto_X, Restriccion = True, Grupo_X = 'G_001', Guia = False):
	
	# Validamos los argumentos de la funcion
	if not str(type(Pt1)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Circulo \n\t {type(Pt1) = }')
	
	if not str(type(Eje)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Crear_Circulo \n\t {type(Eje) = }')
	
	if not type(Radio) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Circulo \n\t {type(Radio) = }')
	
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Circulo \n\t {type(Boceto_X) = }')
	
	
	# aqui guardamos el ID del circulo.
	Lista_Linea.append(list(Boceto_X.addGeometry([Part.Circle(Pt1, Eje, Radio)], Guia)))
	if Restriccion == True:
		# aqui creamos la restriccion Radio del circulo.
		Boceto_X.addConstraint(Sketcher.Constraint('Radius', Lista_Linea[-1][0], Radio))
	# aqui creamos el punto centro del circulo con los valores numericos redondeados
	Eje_Temp = App.Vector(round(Pt1.x, 10), round(Pt1.y, 10), round(Pt1.z, 10))
	# aqui guardamos el punto inicial => (1) y punto final => (2) del circulo => N/A.
	Lista_Linea[-1].append(0)
	Lista_Linea[-1].append(0)
	# aqui guardamos el nombre del circulo.
	Lista_Linea[-1].append('circulo')
	# aqui guardamos el Boceto que contiene al circulo.
	Lista_Linea[-1].append(Boceto_X.Label)
	# aqui guardamos el radio del circulo.
	Lista_Linea[-1].append(round(Radio, 10))
	# aqui guardamos el punto inicial del circulo => N/A.
	Lista_Linea[-1].append([0, 0, 0])
	# aqui guardamos el punto final del circulo => N/A.
	Lista_Linea[-1].append([0, 0, 0])
	# aqui guardamos el punto central del circulo.
	Lista_Linea[-1].append(list(Eje_Temp))
	# aqui guardamos el grupo al que pertenece
	Lista_Linea[-1].append(Grupo_X)
	
	
def Validar_Puntos_de_Contacto(Total_Lista):
	
	for j in range(0, Total_Lista)[::-1]:
		Valor_Futuro = (j - 1) % Total_Lista
		
		# aqui validamos que los puntos sean coincidentes
		
		if Lista_Linea[::-1][j][7] == Lista_Linea[::-1][Valor_Futuro][6]:
			
			if Lista_Linea[::-1][j][2] == 2:
				pass
			else:
				Temp = Lista_Linea[::-1][j][1]
				Lista_Linea[::-1][j][1] = Lista_Linea[::-1][j][2]
				Lista_Linea[::-1][j][2] = Temp
				
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				pass
			else:
				Temp = Lista_Linea[::-1][Valor_Futuro][2]
				Lista_Linea[::-1][Valor_Futuro][2] = Lista_Linea[::-1][Valor_Futuro][1]
				Lista_Linea[::-1][Valor_Futuro][1] = Temp
				
		elif Lista_Linea[::-1][j][7] == Lista_Linea[::-1][Valor_Futuro][7]:
			
			if Lista_Linea[::-1][j][2] == 2:
				pass
			else:
				Temp = Lista_Linea[::-1][j][1]
				Lista_Linea[::-1][j][1] = Lista_Linea[::-1][j][2]
				Lista_Linea[::-1][j][2] = Temp
				
			if Lista_Linea[::-1][Valor_Futuro][1] == 2:
				pass
			else:
				Temp = Lista_Linea[::-1][Valor_Futuro][2]
				Lista_Linea[::-1][Valor_Futuro][2] = Lista_Linea[::-1][Valor_Futuro][1]
				Lista_Linea[::-1][Valor_Futuro][1] = Temp
			
		elif Lista_Linea[::-1][j][6] == Lista_Linea[::-1][Valor_Futuro][6]:
			
			if Lista_Linea[::-1][j][2] == 1:
				pass
			else:
				Temp = Lista_Linea[::-1][j][1]
				Lista_Linea[::-1][j][1] = Lista_Linea[::-1][j][2]
				Lista_Linea[::-1][j][2] = Temp
				
			if Lista_Linea[::-1][Valor_Futuro][1] == 1:
				pass
			else:
				Temp = Lista_Linea[::-1][Valor_Futuro][2]
				Lista_Linea[::-1][Valor_Futuro][2] = Lista_Linea[::-1][Valor_Futuro][1]
				Lista_Linea[::-1][Valor_Futuro][1] = Temp
				
		elif Lista_Linea[::-1][j][6] == Lista_Linea[::-1][Valor_Futuro][7]:
			
			if Lista_Linea[::-1][j][2] == 1:
				pass
			else:
				Temp = Lista_Linea[::-1][j][1]
				Lista_Linea[::-1][j][1] = Lista_Linea[::-1][j][2]
				Lista_Linea[::-1][j][2] = Temp
				
			if Lista_Linea[::-1][Valor_Futuro][1] == 2:
				pass
			else:
				Temp = Lista_Linea[::-1][Valor_Futuro][2]
				Lista_Linea[::-1][Valor_Futuro][2] = Lista_Linea[::-1][Valor_Futuro][1]
				Lista_Linea[::-1][Valor_Futuro][1] = Temp



def Validar_Colineal_Linea_Linea(VP, VF):
	
	# VP = Valor Presente
	# VF = Valor Futuro
	
	# aqui analizamos los vectores de dos lineas
	if Lista_Linea[::-1][VP][3] == 'linea' and Lista_Linea[::-1][VF][3] == 'linea':
		
		if Lista_Linea[::-1][VP][2] == 1:
			Vector01 = App.Vector(Lista_Linea[::-1][VP][6]) - App.Vector(Lista_Linea[::-1][VP][7])
		else:
			Vector01 = App.Vector(Lista_Linea[::-1][VP][7]) - App.Vector(Lista_Linea[::-1][VP][6])
			
		if Lista_Linea[::-1][VF][2] == 1:
			Vector02 = App.Vector(Lista_Linea[::-1][VF][6]) - App.Vector(Lista_Linea[::-1][VF][7])
		else:
			Vector02 = App.Vector(Lista_Linea[::-1][VF][7]) - App.Vector(Lista_Linea[::-1][VF][6])
			
		# calculamos el producto cruz entre los vectores linea
		Vec3 = Vector01.cross(Vector02)
		# si el producto cruz es igual a cero esto significa 
		# que las dos lineas estan alineados, los vectores son paralelos
		if abs(round(Vec3.Length, 5)) == 0:
			Opcion = 'Vectores Colineales Iguales'
		else:
			Opcion = 'Vectores Coplanares'
	else:
		Opcion = 'NA'
		
	return Opcion
	
	
	
def Validar_Colineal_Linea_Arco(VP, VF):
	
	# VP = Valor Presente
	# VF = Valor Futuro
	
	# aqui analizamos los vectores de una linea y un arco
	if Lista_Linea[::-1][VP][3] == 'linea' and Lista_Linea[::-1][VF][3] == 'arco':
		# calculamos el vector de la linea
		if Lista_Linea[::-1][VP][2] == 1:
			Vector01 = App.Vector(Lista_Linea[::-1][VP][6]) - App.Vector(Lista_Linea[::-1][VP][7])
		else:
			Vector01 = App.Vector(Lista_Linea[::-1][VP][7]) - App.Vector(Lista_Linea[::-1][VP][6])
		
		# Si el punto inicial esta en la misma ubicacion del angulo inicial 
		# entonces el giro del angulo es en contra de las manecillas del reloj
		# por lo tanto su Normal Esperado es positiva.
		if Lista_Linea[::-1][VF][1] == 1:
			Normal02_Esperada = App.Vector(0, 0, 1)
		else:
			Normal02_Esperada = App.Vector(0, 0, -1)
		# ahora se calcula el vector centro a extremo inicial del arco
		if Lista_Linea[::-1][VF][1] == 1:
			Vector02_CE = App.Vector(Lista_Linea[::-1][VF][6]) - App.Vector(Lista_Linea[::-1][VF][8])
		else:
			Vector02_CE = App.Vector(Lista_Linea[::-1][VF][7]) - App.Vector(Lista_Linea[::-1][VF][8])
		# ahora se calculan los vectores perpendiculares al extremo inicial del arco
		Vector02_P1 = App.Vector(-Vector02_CE.y, Vector02_CE.x, 0)
		Vector02_P2 = App.Vector(Vector02_CE.y, -Vector02_CE.x, 0)
		# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
		Normal02_P1 = Vector02_CE.cross(Vector02_P1)
		Normal02_P2 = Vector02_CE.cross(Vector02_P2)
		# ahora calculamos la Normal Unitaria
		Normal02_P1 = Normal02_P1 / Normal02_P1.Length
		Normal02_P2 = Normal02_P2 / Normal02_P2.Length
		# ahora se compara el signo de la Normal Esperada con
		# el signo de la Normal perpendicular,
		# si ambos son iguales significa que el vector perpendicular el es correcto.
		if Normal02_Esperada == Normal02_P1:
			Vector02_P = Vector02_P1
		elif Normal02_Esperada == Normal02_P2:
			Vector02_P = Vector02_P2
		
		# calculamos el producto cruz entre los vectores linea y tangente del arco
		Vec3 = Vector01.cross(Vector02_P)
		# Ahora sumamos los dos vectores perpendiculares de los arcos
		Vector_T = Vector01 + Vector02_P
		# si el producto cruz es igual a cero
		# significa que los extremos de los arcos estan alineados.
		if abs(round(Vec3.Length, 5)) == 0:
			# si ambos vectores se suman y la magnitud es mayor al vector inicial
			# significa que los vectores estan en el mismo sentido.
			if Vector_T.Length > Vector01.Length:
				Opcion = 'Vectores Colineales Iguales'
			else:
				Opcion = 'Vectores Colineales Opuestos'
		else:
			Opcion = 'Vectores Coplanares'	
	else:
		Opcion = 'NA'
			
	return Opcion
	
	
	
def Validar_Colineal_Arco_Linea(VP, VF):
	
	# VP = Valor Presente
	# VF = Valor Futuro
	
	# aqui analizamos los vectores de un arco y una linea
	if Lista_Linea[::-1][VP][3] == 'arco' and Lista_Linea[::-1][VF][3] == 'linea':
		# Si el punto inicial esta en la misma ubicacion del angulo inicial 
		# entonces el giro del angulo es en contra de las manecillas del reloj
		# por lo tanto su Normal Esperado es positiva.
		if Lista_Linea[::-1][VP][1] == 1:
			Normal01_Esperada = App.Vector(0, 0, 1)
		else:
			Normal01_Esperada = App.Vector(0, 0, -1)
		# ahora se calcula el vector centro a extremo final del arco
		if Lista_Linea[::-1][VP][2] == 1:
			Vector01_CE = App.Vector(Lista_Linea[::-1][VP][6]) - App.Vector(Lista_Linea[::-1][VP][8])
		else:
			Vector01_CE = App.Vector(Lista_Linea[::-1][VP][7]) - App.Vector(Lista_Linea[::-1][VP][8])
		# ahora se calculan los vectores perpendiculares al extremo final del arco
		Vector01_P1 = App.Vector(-Vector01_CE.y, Vector01_CE.x, 0)
		Vector01_P2 = App.Vector(Vector01_CE.y, -Vector01_CE.x, 0)
		# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
		Normal01_P1 = Vector01_CE.cross(Vector01_P1)
		Normal01_P2 = Vector01_CE.cross(Vector01_P2)
		# ahora calculamos la Normal Unitaria
		Normal01_P1 = Normal01_P1 / Normal01_P1.Length
		Normal01_P2 = Normal01_P2 / Normal01_P2.Length
		# ahora se compara el signo de la Normal Esperada con
		# el signo de la Normal perpendicular,
		# si ambos son iguales significa que el vector perpendicular el es correcto.
		if Normal01_Esperada == Normal01_P1:
			Vector01_P = Vector01_P1
		elif Normal01_Esperada == Normal01_P2:
			Vector01_P = Vector01_P2
		
		# calculamos el vector de la linea
		if Lista_Linea[::-1][VF][2] == 1:
			Vector02 = App.Vector(Lista_Linea[::-1][VF][6]) - App.Vector(Lista_Linea[::-1][VF][7])
		else:
			Vector02 = App.Vector(Lista_Linea[::-1][VF][7]) - App.Vector(Lista_Linea[::-1][VF][6])
		
		# calculamos el producto cruz entre los vectores tangente del arco y linea
		Vec3 = Vector01_P.cross(Vector02)
		# Ahora sumamos los dos vectores perpendiculares de los arcos
		Vector_T = Vector01_P + Vector02
		# si el producto cruz es igual a cero
		# significa que los extremos de los arcos estan alineados.
		if abs(round(Vec3.Length, 5)) == 0:
			# si ambos vectores se suman y la magnitud es mayor al vector inicial
			# significa que los vectores estan en el mismo sentido.
			if Vector_T.Length > Vector01_P.Length:
				Opcion = 'Vectores Colineales Iguales'
			else:
				Opcion = 'Vectores Colineales Opuestos'
		else:
			Opcion = 'Vectores Coplanares'
	else:
		Opcion = 'NA'
		
	return Opcion
	
	
def Validar_Colineal_Arco_Arco(VP, VF):
	
	# VP = Valor Presente
	# VF = Valor Futuro
	
	# aqui analizamos los vectores de dos arcos
	if Lista_Linea[::-1][VP][3] == 'arco' and Lista_Linea[::-1][VF][3] == 'arco':
		# Si el punto inicial esta en la misma ubicacion del angulo inicial 
		# entonces el giro del angulo es en contra de las manecillas del reloj
		# por lo tanto su Normal Esperado es positiva.
		if Lista_Linea[::-1][VP][1] == 1:
			Normal01_Esperada = App.Vector(0, 0, 1)
		else:
			Normal01_Esperada = App.Vector(0, 0, -1)
		# ahora se calcula el vector centro a extremo final del arco
		if Lista_Linea[::-1][VP][2] == 1:
			Vector01_CE = App.Vector(Lista_Linea[::-1][VP][6]) - App.Vector(Lista_Linea[::-1][VP][8])
		else:
			Vector01_CE = App.Vector(Lista_Linea[::-1][VP][7]) - App.Vector(Lista_Linea[::-1][VP][8])
		# ahora se calculan los vectores perpendiculares al extremo final del arco
		Vector01_P1 = App.Vector(-Vector01_CE.y, Vector01_CE.x, 0)
		Vector01_P2 = App.Vector(Vector01_CE.y, -Vector01_CE.x, 0)
		# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
		Normal01_P1 = Vector01_CE.cross(Vector01_P1)
		Normal01_P2 = Vector01_CE.cross(Vector01_P2)
		# ahora calculamos la Normal Unitaria
		Normal01_P1 = Normal01_P1 / Normal01_P1.Length
		Normal01_P2 = Normal01_P2 / Normal01_P2.Length
		# ahora se compara el signo de la Normal Esperada con
		# el signo de la Normal perpendicular,
		# si ambos son iguales significa que el vector perpendicular el es correcto.
		if Normal01_Esperada == Normal01_P1:
			Vector01_P = Vector01_P1
		elif Normal01_Esperada == Normal01_P2:
			Vector01_P = Vector01_P2
		
		# Si el punto inicial esta en la misma ubicacion del angulo inicial 
		# entonces el giro del angulo es en contra de las manecillas del reloj
		# por lo tanto su Normal Esperado es positiva.
		if Lista_Linea[::-1][VF][1] == 1:
			Normal02_Esperada = App.Vector(0, 0, 1)
		else:
			Normal02_Esperada = App.Vector(0, 0, -1)
		# ahora se calcula el vector centro a extremo inicial del arco
		if Lista_Linea[::-1][VF][1] == 1:
			Vector02_CE = App.Vector(Lista_Linea[::-1][VF][6]) - App.Vector(Lista_Linea[::-1][VF][8])
		else:
			Vector02_CE = App.Vector(Lista_Linea[::-1][VF][7]) - App.Vector(Lista_Linea[::-1][VF][8])
		# ahora se calculan los vectores perpendiculares al extremo inicial del arco
		Vector02_P1 = App.Vector(-Vector02_CE.y, Vector02_CE.x, 0)
		Vector02_P2 = App.Vector(Vector02_CE.y, -Vector02_CE.x, 0)
		# ahora calculamos la normal entre los vectores perpendiculares y el vector centro del arco
		Normal02_P1 = Vector02_CE.cross(Vector02_P1)
		Normal02_P2 = Vector02_CE.cross(Vector02_P2)
		# ahora calculamos la Normal Unitaria
		Normal02_P1 = Normal02_P1 / Normal02_P1.Length
		Normal02_P2 = Normal02_P2 / Normal02_P2.Length
		# ahora se compara el signo de la Normal Esperada con
		# el signo de la Normal perpendicular,
		# si ambos son iguales significa que el vector perpendicular el es correcto.
		if Normal02_Esperada == Normal02_P1:
			Vector02_P = Vector02_P1
		elif Normal02_Esperada == Normal02_P2:
			Vector02_P = Vector02_P2
			
		# calculamos el producto cruz entre los vectores centro de cada arco
		Vec3 = Vector01_CE.cross(Vector02_CE)
		# Ahora sumamos los dos vectores perpendiculares de los arcos
		Vector_T = Vector01_P + Vector02_P
		# si el producto cruz es igual a cero
		# significa que los extremos de los arcos estan alineados.
		if abs(round(Vec3.Length, 5)) == 0:
			# si ambos vectores se suman y la magnitud es mayor al vector inicial
			# significa que los vectores estan en el mismo sentido.
			if Vector_T.Length > Vector01_P.Length:
				Opcion = 'Vectores Colineales Iguales'
			else:
				Opcion = 'Vectores Colineales Opuestos'
		else:
			Opcion = 'Vectores Coplanares'
	else:
		Opcion = 'NA'
	
	return Opcion


def Unir_Lineas(Boceto_X, Total_Lista):
	
	# Validamos los argumentos de la funcion
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Unir_Lineas \n\t {type(Boceto_X) = }')
	
	if not type(Total_Lista) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Unir_Lineas \n\t {type(Total_Lista) = }')
	
	
	# aqui seleccionamos los 'n' ultimos elementos de la lista.
	for j in range(0, Total_Lista)[::-1]:
		# aqui seleccionamos el 'n + 1' elemento de la lista
		Valor_Futuro = (j - 1) % Total_Lista
		
		match Lista_Linea[::-1][j][3] + '_' + Lista_Linea[::-1][Valor_Futuro][3]:
			
			case 'linea_linea':
				# Validar_Colineal_Linea_Linea(VP, VF):
				Opcion = Validar_Colineal_Linea_Linea(j, Valor_Futuro)
				
			case 'linea_arco':
				# Validar_Colineal_Linea_Arco(VP, VF):
				Opcion = Validar_Colineal_Linea_Arco(j, Valor_Futuro)
				
			case 'arco_linea':
				# Validar_Colineal_Arco_Linea(VP, VF):
				Opcion = Validar_Colineal_Arco_Linea(j, Valor_Futuro)
				
			case 'arco_arco':
				# Validar_Colineal_Arco_Arco(VP, VF):
				Opcion = Validar_Colineal_Arco_Arco(j, Valor_Futuro)
				
			case _:
				Opcion = 'NA'
		
		if Opcion == 'Vectores Colineales Iguales':
			Boceto_X.addConstraint(Sketcher.Constraint('Tangent', Lista_Linea[::-1][j][0], Lista_Linea[::-1][j][2], Lista_Linea[::-1][Valor_Futuro][0], Lista_Linea[::-1][Valor_Futuro][1]))
		if Opcion == 'Vectores Coplanares' or Opcion == 'Vectores Colineales Opuestos':
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[::-1][j][0], Lista_Linea[::-1][j][2], Lista_Linea[::-1][Valor_Futuro][0], Lista_Linea[::-1][Valor_Futuro][1]))
	
	
	Plano.recompute()
	

def Bloquear_Lineas(Boceto_X, Total_Lista):
	
	# Validamos los argumentos de la funcion
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Bloquear_Lineas \n\t {type(Boceto_X) = }')
	
	if not type(Total_Lista) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Bloquear_Lineas \n\t {type(Total_Lista) = }')
	
	
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'linea':
			Boceto_X.addConstraint(Sketcher.Constraint('Block', Lista_Linea[::-1][j][0]))
	
	Plano.recompute()


def Bloquear_Arcos(Boceto_X, Total_Lista):
	
	# Validamos los argumentos de la funcion
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Bloquear_Arcos \n\t {type(Boceto_X) = }')
	
	if not type(Total_Lista) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Bloquear_Arcos \n\t {type(Total_Lista) = }')
	
	
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'arco':
			Boceto_X.addConstraint(Sketcher.Constraint('Block', Lista_Linea[::-1][j][0]))
			
	Plano.recompute()
	
	
def Bloquear_Circulos(Boceto_X, Total_Lista):
	
	# Validamos los argumentos de la funcion
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Bloquear_Circulos \n\t {type(Boceto_X) = }')
	
	if not type(Total_Lista) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Bloquear_Circulos \n\t {type(Total_Lista) = }')
	
	
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'circulo':
			Boceto_X.addConstraint(Sketcher.Constraint('Block', Lista_Linea[::-1][j][0]))
	
	Plano.recompute()
	
	
def Fijar_Circulo_Origen(Pt1, Boceto_X, Index_Obj):
	
	# Validamos los argumentos de la funcion
	if not str(type(Pt1)) in ("<class 'Base.Vector'>"):
		raise TypeError(f'\n\n\t Mensaje = No es Vector \n\t Funcion = Fijar_Circulo_Origen \n\t {type(Pt1) = }')
		
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Fijar_Circulo_Origen \n\t {type(Boceto_X) = }')
		
	if not type(Indx_Obj) is int:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Fijar_Circulo_Origen \n\t {type(Index_Obj) = }')
	
	
	if list(Pt1)[0] >= 0:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', -1,1,Index_Obj,3, abs(list(Pt1)[0])))
	else:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', Index_Obj,3,-1,1, abs(list(Pt1)[0])))
	if list(Pt1)[1] >= 0:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceY', -1,1,Index_Obj,3, abs(list(Pt1)[1])))
	else:
		Boceto_X.addConstraint(Sketcher.Constraint('DistanceY', Index_Obj,3,-1,1, abs(list(Pt1)[1])))
	
	Plano.recompute()
	
	
def Restriccion_Ortogonal_Linea(Boceto_X, Total_Lista, Desfase = -1):
	
	Lista_ID = []
	Grupo_Linea = []
	
	if Desfase == -1:
		Val_Ini = 0
	else:
		Val_Ini = 1
	
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == 'linea':
			VF = (j - 1) % Total_Lista
			if Lista_Linea[::-1][VF][3] == 'linea':
				# Validar_Colineal_Linea_Linea(VP, VF):
				Opcion = Validar_Colineal_Linea_Linea(j, VF)
				if Opcion == 'Vectores Coplanares':
					Grupo_Linea.append(Lista_Linea[::-1][j])
			else:
				Grupo_Linea.append(Lista_Linea[::-1][j])
	
	for k in range(Val_Ini, len(Grupo_Linea)):
		if Grupo_Linea[k][6][0] == Grupo_Linea[k][7][0] and Grupo_Linea[k][6][1] != Grupo_Linea[k][7][1]:
			Boceto_X.addConstraint(Sketcher.Constraint('Vertical', Grupo_Linea[k][0]))
		if Grupo_Linea[k][6][0] != Grupo_Linea[k][7][0] and Grupo_Linea[k][6][1] == Grupo_Linea[k][7][1]:
			Boceto_X.addConstraint(Sketcher.Constraint('Horizontal', Grupo_Linea[k][0]))
	
	Plano.recompute()
	
	
def Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
	
	Arco_ID = []
	Restriccion_ID = []
	Grupo_Obj = []
	
	for j in range(0, Total_Lista)[::-1]:
		if Lista_Linea[::-1][j][3] == Obj_X:
			Grupo_Obj.append(Lista_Linea[::-1][j])
	
	for k in range(0, len(Grupo_Obj)):
		if k in Omitir:
			pass
		else:
			Arco_ID.append(Grupo_Obj[k][0])
			if len(Arco_ID) == 1:
				if Restriccion == True:
					Restriccion_ID.append(Boceto_X.addConstraint(Sketcher.Constraint('Radius', Arco_ID[0], Grupo_Obj[k][5])))
					if Titulo == 'Radio_Pral':
						Boceto_X.renameConstraint(Restriccion_ID[-1], Titulo)
						Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
						Boceto_X.setExpression('.Constraints.Radio_Pral', u'VarSet001.Aro_Radio < 35 mm ? 35 mm : (VarSet001.Aro_Radio > 100 mm ? 100 mm : VarSet001.Aro_Radio)')
						
						Lista_Restriccion.append(list(Restriccion_ID))
						Lista_Restriccion[-1].append('Radius')
						Lista_Restriccion[-1].append(Arco_ID[0])
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append(Grupo_Obj[k][5])
						Lista_Restriccion[-1].append(Titulo)
						Lista_Restriccion[-1].append(Grupo_Obj[k][9])
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append(Boceto_X.Label)
						
					else:
						# aqui validamos si el Titulo_Y esta repetido
						if len(Titulo.split('_')) == 1:
							Titulo_Temp = Titulo + '_01'
						else:
							Titulo_Temp = Titulo
						
						for t in range(0, len(Lista_Restriccion)):
							for f in range(0, len(Lista_Restriccion)):
								if Titulo_Temp == Lista_Restriccion[f][7] and Boceto_X.Label == Lista_Restriccion[f][10]:
									Titulo_Temp = Titulo_Temp.split('_')[0] + '_' + str(int(Titulo_Temp.split('_')[1]) + 1).zfill(2)
									break
						
						Boceto_X.renameConstraint(Restriccion_ID[-1], Titulo_Temp)
						Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
						
						if Titulo_Temp.split('_')[0] == 'Iman':
							Boceto_X.setExpression('.Constraints.' + Titulo_Temp, u'VarSet001.Radio_Iman > VarSet001.Aro_Grosor / 2 ? VarSet001.Aro_Grosor / 2 : (VarSet001.Radio_Iman < 3 mm ? 3 mm : VarSet001.Radio_Iman)')
						elif Titulo_Temp.split('_')[0] == 'Hoyo':
							Boceto_X.setExpression('.Constraints.' + Titulo_Temp, u'VarSet001.Radio_Agujero > 3 mm ? 3 mm : (VarSet001.Radio_Agujero < 1 mm ? 1 mm : VarSet001.Radio_Agujero)')
						else:
							pass
						
						Lista_Restriccion.append(list(Restriccion_ID))
						Lista_Restriccion[-1].append('Radius')
						Lista_Restriccion[-1].append(Arco_ID[0])
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append(Grupo_Obj[k][5])
						Lista_Restriccion[-1].append(Titulo_Temp)
						Lista_Restriccion[-1].append(Grupo_Obj[k][9])
						Lista_Restriccion[-1].append('NA')
						Lista_Restriccion[-1].append(Boceto_X.Label)
						
					
					
			elif len(Arco_ID) == 2:
				Boceto_X.addConstraint(Sketcher.Constraint('Equal', Arco_ID[0], Arco_ID[1]))
				Arco_ID = [Arco_ID[1]]
				
	Plano.recompute()
				
				
def Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Valor_X, Desfase = False, Grupo_Base_X = ['G_001', 'G_002'], Titulo_Y = 'Margen_01'):
	
	Linea01_ID = []
	Linea02_ID = []
	Restriccion_ID = []
	Grupo_A = []
	Grupo_B = []
	
	for k in range(0, len(Lista_Linea)):
		if Lista_Linea[k][4] == Boceto_X.Label and Lista_Linea[k][9] == Grupo_Base_X[0]:
			Grupo_A.append(Lista_Linea[k])
		if Lista_Linea[k][4] == Boceto_X.Label and Lista_Linea[k][9] == Grupo_Base_X[1]:
			Grupo_B.append(Lista_Linea[k])
	
	for j in range(0, len(Lista_X))[::-1]:
		if Lista_X[::-1][j][0] == 'linea' and Lista_X[::-1][j][1] == 'Vertical':
			Linea01_ID.append(Grupo_A[::-1][j][0])
			if Desfase == True:
				Linea02_ID.append(Grupo_B[::-1][j][0])
				
			if len(Linea01_ID) == 2:
				if Desfase == False:
					Restriccion_ID.append(Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', Linea01_ID[1], 2, Linea01_ID[0], 1, Valor_X)))
					Boceto_X.renameConstraint(Restriccion_ID[-1], Titulo_Y)
					Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
					Boceto_X.setExpression('.Constraints.' + Titulo_Y, 'VarSet001.Aro_Largo < 2 * VarSet001.Aro_Radio + 50 mm ? 2 * VarSet001.Aro_Radio + 50 mm : (VarSet001.Aro_Largo > 800 mm ? 800 mm : VarSet001.Aro_Largo)')
					
					Lista_Restriccion.append(list(Restriccion_ID))
					Lista_Restriccion[-1].append('DistanceX')
					Lista_Restriccion[-1].append(Linea01_ID[1])
					Lista_Restriccion[-1].append(2)
					Lista_Restriccion[-1].append(Linea01_ID[0])
					Lista_Restriccion[-1].append(1)
					Lista_Restriccion[-1].append(Valor_X)
					Lista_Restriccion[-1].append(Titulo_Y)
					Lista_Restriccion[-1].append(Grupo_A[::-1][j][9])
					Lista_Restriccion[-1].append(Grupo_A[::-1][j][9])
					Lista_Restriccion[-1].append(Boceto_X.Label)
					
				else:
					# aqui validamos si el Titulo_Y esta repetido
					if len(Titulo_Y.split('_')) == 1:
						Titulo_Y = Titulo_Y + '_01'
					
					for t in range(0, len(Lista_Restriccion)):
						for k in range(0, len(Lista_Restriccion)):
							if Titulo_Y == Lista_Restriccion[k][7] and Boceto_X.Label == Lista_Restriccion[k][10]:
								Titulo_Y = Titulo_Y.split('_')[0] + '_' + str(int(Titulo_Y.split('_')[1]) + 1).zfill(2)
								break
					
					Restriccion_ID.append(Boceto_X.addConstraint(Sketcher.Constraint('DistanceX', Linea01_ID[0], 1, Linea02_ID[0], 1, Valor_X)))
					Boceto_X.renameConstraint(Restriccion_ID[-1], Titulo_Y)
					Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
					
					if Titulo_Y.split('_')[0] == 'Margen':
						Boceto_X.setExpression('.Constraints.' + Titulo_Y, 'VarSet001.Aro_Margen < 1 mm ? 1 mm : (VarSet001.Aro_Margen > 50 mm ? 50 mm : VarSet001.Aro_Margen)')
					if Titulo_Y.split('_')[0] == 'Grosor':
						Boceto_X.setExpression('.Constraints.' + Titulo_Y, 'VarSet001.Aro_Grosor < 10 mm ? 10 mm : (VarSet001.Aro_Grosor > 100 mm ? 100 mm : VarSet001.Aro_Grosor)')
					if Titulo_Y.split('_')[0] == 'Tapadera':
						Boceto_X.setExpression('.Constraints.' + Titulo_Y, 'VarSet001.Tap_Grosor < 10 mm ? 10 mm : (VarSet001.Tap_Grosor > 100 mm ? 100 mm : VarSet001.Tap_Grosor)')
					
					Lista_Restriccion.append(list(Restriccion_ID))
					Lista_Restriccion[-1].append('DistanceX')
					Lista_Restriccion[-1].append(Linea02_ID[0])
					Lista_Restriccion[-1].append(1)
					Lista_Restriccion[-1].append(Linea01_ID[0])
					Lista_Restriccion[-1].append(1)
					Lista_Restriccion[-1].append(Valor_X)
					Lista_Restriccion[-1].append(Titulo_Y)
					Lista_Restriccion[-1].append(Grupo_B[::-1][j][9])
					Lista_Restriccion[-1].append(Grupo_A[::-1][j][9])
					Lista_Restriccion[-1].append(Boceto_X.Label)
					
	Plano.recompute()
					
				
def Restriccion_DistanciaY_linea(Lista_X, Boceto_X, Valor_X, Desfase = False, Grupo_Base_X = ['G_001', 'G_002'], Titulo_Y = 'Margen_01'):
	
	Linea01_ID = []
	Linea02_ID = []
	Restriccion_ID = []
	Grupo_A = []
	Grupo_B = []
	
	for k in range(0, len(Lista_Linea)):
		if Lista_Linea[k][4] == Boceto_X.Label and Lista_Linea[k][9] == Grupo_Base_X[0]:
			Grupo_A.append(Lista_Linea[k])
		if Lista_Linea[k][4] == Boceto_X.Label and Lista_Linea[k][9] == Grupo_Base_X[1]:
			Grupo_B.append(Lista_Linea[k])
	
	for j in range(0, len(Lista_X))[::-1]:
		if Lista_X[::-1][j][0] == 'linea' and Lista_X[::-1][j][1] == 'Horizontal':
			Linea01_ID.append(Grupo_A[::-1][j][0])
			if Desfase == True:
				Linea02_ID.append(Grupo_B[::-1][j][0])
			
			if len(Linea01_ID) == 2:
				if Desfase == False:
					Restriccion_ID.append(Boceto_X.addConstraint(Sketcher.Constraint('DistanceY', Linea01_ID[1], 2, Linea01_ID[0], 1, Valor_X)))
					Boceto_X.renameConstraint(Restriccion_ID[-1], Titulo_Y)
					Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
					Boceto_X.setExpression('.Constraints.' + Titulo_Y, u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? 2 * VarSet001.Aro_Radio + 50 mm : (VarSet001.Aro_Alto > 800 mm ? 800 mm : VarSet001.Aro_Alto)')
					
					Lista_Restriccion.append(list(Restriccion_ID))
					Lista_Restriccion[-1].append('DistanceY')
					Lista_Restriccion[-1].append(Linea01_ID[1])
					Lista_Restriccion[-1].append(2)
					Lista_Restriccion[-1].append(Linea01_ID[0])
					Lista_Restriccion[-1].append(1)
					Lista_Restriccion[-1].append(Valor_X)
					Lista_Restriccion[-1].append(Titulo_Y)
					Lista_Restriccion[-1].append(Grupo_A[::-1][j][9])
					Lista_Restriccion[-1].append(Grupo_A[::-1][j][9])
					Lista_Restriccion[-1].append(Boceto_X.Label)
				else:
					# aqui validamos si el Titulo_Y esta repetido
					if len(Titulo_Y.split('_')) == 1:
						Titulo_Y = Titulo_Y + '_01'
					
					for t in range(0, len(Lista_Restriccion)):
						for k in range(0, len(Lista_Restriccion)):
							if Titulo_Y == Lista_Restriccion[k][7] and Boceto_X.Label == Lista_Restriccion[k][10]:
								Titulo_Y = Titulo_Y.split('_')[0] + '_' + str(int(Titulo_Y.split('_')[1]) + 1).zfill(2)
								break
					
					Restriccion_ID.append(Boceto_X.addConstraint(Sketcher.Constraint('DistanceY', Linea02_ID[0], 1, Linea01_ID[0], 1, Valor_X)))
					Boceto_X.renameConstraint(Restriccion_ID[-1], Titulo_Y)
					Boceto_X.setVirtualSpace(Restriccion_ID[-1], False)
					
					if Titulo_Y.split('_')[0] == 'Margen':
						Boceto_X.setExpression('.Constraints.' + Titulo_Y, 'VarSet001.Aro_Margen < 1 mm ? 1 mm : (VarSet001.Aro_Margen > 50 mm ? 50 mm : VarSet001.Aro_Margen)')
					if Titulo_Y.split('_')[0] == 'Grosor':
						Boceto_X.setExpression('.Constraints.' + Titulo_Y, 'VarSet001.Aro_Grosor < 10 mm ? 10 mm : (VarSet001.Aro_Grosor > 100 mm ? 100 mm : VarSet001.Aro_Grosor)')
					
					Lista_Restriccion.append(list(Restriccion_ID))
					Lista_Restriccion[-1].append('DistanceY')
					Lista_Restriccion[-1].append(Linea02_ID[0])
					Lista_Restriccion[-1].append(1)
					Lista_Restriccion[-1].append(Linea01_ID[0])
					Lista_Restriccion[-1].append(1)
					Lista_Restriccion[-1].append(Valor_X)
					Lista_Restriccion[-1].append(Titulo_Y)
					Lista_Restriccion[-1].append(Grupo_B[::-1][j][9])
					Lista_Restriccion[-1].append(Grupo_A[::-1][j][9])
					Lista_Restriccion[-1].append(Boceto_X.Label)
				
	Plano.recompute()
				
				
def Simetria_Objeto_Eje(Lista_X, Boceto_X, Objeto, Eje = -1, Paso = 1):
	
	'''
	Nota:
		Eje = -1 => es para el eje X
		Eje = -2 => es para el eje Y 
	'''
	
	Objeto_ID = []
	Contador = 0
	
	for j in range(0, len(Lista_X))[::-1]:
		if Lista_Linea[::-1][j][3] == Objeto:
			Contador += 1
			if Contador % Paso == 0:
				Objeto_ID.append(Lista_Linea[::-1][j][0])
	
	Boceto_X.addConstraint(Sketcher.Constraint('Symmetric', Objeto_ID[0], 3, Objeto_ID[1], 3, Eje, 1))
	
	Plano.recompute()
	
	
def Restriccion_Coincidente_Arco(Lista_X, Boceto_X, Grupo_Base_X = ['G_001', 'G_002']):
	
	Lista01_ID = []
	Lista02_ID = []
	
	Grupo_A = []
	Grupo_B = []
	
	for t in range(0, len(Lista_Linea)):
		if Lista_Linea[t][9] == Grupo_Base_X[0]:
			Grupo_A.append(Lista_Linea[t])
		if Lista_Linea[t][9] == Grupo_Base_X[1]:
			Grupo_B.append(Lista_Linea[t])
	
	for j in range(0, len(Lista_X)):
		if Lista_X[j][0] == 'arco':
			Lista01_ID.append(Grupo_A[j][0])
			Lista02_ID.append(Grupo_B[j][0])
	
	for k in range(0, len(Lista01_ID)):
		Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista01_ID[k], 3, Lista02_ID[k], 3))
		
	Plano.recompute()
	
	
def Mostrar_Ultimo_Grupo(Boceto_X):
	
	# aqui mostramos el ultimo Grupo generado en la Lista_Linea
	Lista_Grupo = []
	if len(Lista_Linea) == 0:
		Grupo_Y = 'G_001'
	else:
		for k in range(0, len(Lista_Linea)):
			if Lista_Linea[k][4] == Boceto_X.Label:
				Lista_Grupo.append(Lista_Linea[k][9])
		if len(Lista_Grupo) == 0:
			Grupo_Y = 'G_001'
		else:
			Lista_Grupo = sorted(list(set(Lista_Grupo)))
			Grupo_Y = Lista_Grupo[-1]
			
	return Grupo_Y
	
	
def Actualizar_Grupo(Boceto_X):
	
	# aqui actualizamos el Grupo al que pertenencen los objetos
	Lista_Grupo = []
	if len(Lista_Linea) == 0:
		Grupo_Y = 'G_001'
	else:
		for k in range(0, len(Lista_Linea)):
			if Lista_Linea[k][4] == Boceto_X.Label:
				Lista_Grupo.append(Lista_Linea[k][9])
		if len(Lista_Grupo) == 0:
			Grupo_Y = 'G_001'
		else:		
			Lista_Grupo = sorted(list(set(Lista_Grupo)))
			Grupo_Y = 'G_' + str(int(Lista_Grupo[-1].split('_')[1]) + 1).zfill(3)
			
	return Grupo_Y
	
	
def Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
	
	if Indice_X % 2 == 0:
		Eje_Temp = -2
		Restriccion_Temp = 'DistanceX'
	else:
		Eje_Temp = -1
		Restriccion_Temp = 'DistanceY'
	
	# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
	Crear_Linea(Lista_Circulo[Indice_X][1][0][6], Lista_Circulo[Indice_X][1][1][6], Boceto_X, Grupo_X = Grupo_Temp, Guia = True)
	
	Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Circulo[Indice_X][1][0][0], 1, Lista_Linea[-1][0], 1))
	Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Circulo[Indice_X][1][1][0], 1, Lista_Linea[-1][0], 2))
	
	Plano.recompute()
	
	# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
	Crear_Linea(Lista_Circulo[Indice_X][1][0][7], Lista_Circulo[Indice_X][1][1][7], Boceto_X, Grupo_X = Grupo_Temp, Guia = True)
	
	Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Circulo[Indice_X][1][0][0], 2, Lista_Linea[-1][0], 1))
	Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Circulo[Indice_X][1][1][0], 2, Lista_Linea[-1][0], 2))
	
	Plano.recompute()
	
	# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
	Crear_Linea(Lista_Circulo[Indice_X][1][0][6], Lista_Circulo[Indice_X][1][0][7], Boceto_X, Grupo_X = Grupo_Temp, Guia = True)
	
	Boceto_X.addConstraint(Sketcher.Constraint('Symmetric', Lista_Circulo[Indice_X][1][0][0], 1, Lista_Circulo[Indice_X][1][1][0], 1, Lista_Linea[-1][0], 1))
	Boceto_X.addConstraint(Sketcher.Constraint('Symmetric', Lista_Circulo[Indice_X][1][0][0], 2, Lista_Circulo[Indice_X][1][1][0], 2, Lista_Linea[-1][0], 2))
	
	Plano.recompute()
	
	for y in range(0, len(Lista_Circulo[Indice_X][2])):
		Boceto_X.addConstraint(Sketcher.Constraint('PointOnObject', Lista_Circulo[Indice_X][2][y][0], 3, Lista_Linea[-1][0]))
	
	for w in range(0, len(Lista_Circulo[Indice_X][2])):
		Boceto_X.addConstraint(Sketcher.Constraint(Restriccion_Temp, Eje_Temp, 1, Lista_Circulo[Indice_X][2][w][0], 3, list(Lista_Circulo[Indice_X][2][w][8])[Indice_X % 2]))
	
	Plano.recompute()
	
	
def Fijar_Agujeros_a_Cuerpo(Lista01_X, Lista02_X, Boceto_X, Grupo_X, Grupo_Y):
	
	Lista01_Y = []
	Lista02_Y = []
	Lista_Circulo = []
	
	# Mostrar_Ultimo_Grupo(Boceto_X):
	Grupo_Z = Mostrar_Ultimo_Grupo(Boceto_X)
	
	# Actualizar_Grupo(Boceto_X):
	Grupo_Temp = Actualizar_Grupo(Boceto_X)
	
	for k in range(0, len(Lista01_X)):
		Lista01_Y.append([Lista01_X[k][0], Lista01_X[k][1]])
	
	for k in range(0, len(Lista01_X)):
		if [Lista02_X[k][0], Lista02_X[k][1], Lista02_X[k][2]] in Lista02_Y:
			pass
		else:
			Lista02_Y.append([Lista02_X[k][0], Lista02_X[k][1], Lista02_X[k][2]])
	
	for j in range(0, len(Lista02_Y)):
		Lista_Circulo.append([])
		Lista_Circulo[j].append(Lista02_Y[j])
		Lista_Circulo[j].append([])
		Lista_Circulo[j].append([])
		
		Lista01_G = []
		Lista02_G = []
		
		for k in range(0, len(Lista_Linea)):
			if Lista_Linea[k][9] == Grupo_X:
				Lista01_G.append(Lista_Linea[k])
		
		for k in range(0, len(Lista_Linea)):
			if Lista_Linea[k][9] == Grupo_Y:
				Lista02_G.append(Lista_Linea[k])
		
		for t in range(0, len(Lista01_Y)):
			if Lista01_Y[t][0] == 'linea' and 2 * j == t:
				Lista_Circulo[j][1].append(Lista01_G[t])
				Lista_Circulo[j][1].append(Lista02_G[t])
		
		
		if j == 0:
			for f in range(0, len(Lista_Linea)):
				if Lista_Linea[f][3] == 'circulo' and Lista_Linea[f][9] == Grupo_Z and Lista_Linea[f][4] == Boceto_X.Label:
					if Lista02_Y[j][1] * Lista02_Y[j][2] == list(Lista_Linea[f][8])[1]:
						Lista_Circulo[j][2].append(Lista_Linea[f])
			
			# Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
			Restriccion_Agujeros_a_Cuerpo(j, Lista_Circulo, Boceto_X, Grupo_Temp)
		
		
		if j == 1:
			for f in range(0, len(Lista_Linea)):
				if Lista_Linea[f][3] == 'circulo' and Lista_Linea[f][9] == Grupo_Z and Lista_Linea[f][4] == Boceto_X.Label:
					if Lista02_Y[j][1] * Lista02_Y[j][2] == list(Lista_Linea[f][8])[0]:
						Lista_Circulo[j][2].append(Lista_Linea[f])
						
			# Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
			Restriccion_Agujeros_a_Cuerpo(j, Lista_Circulo, Boceto_X, Grupo_Temp)
		
		
		if j == 2:
			for f in range(0, len(Lista_Linea)):
				if Lista_Linea[f][3] == 'circulo' and Lista_Linea[f][9] == Grupo_Z and Lista_Linea[f][4] == Boceto_X.Label:
					if Lista02_Y[j][1] * Lista02_Y[j][2] == list(Lista_Linea[f][8])[1]:
						Lista_Circulo[j][2].append(Lista_Linea[f])
						
			# Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
			Restriccion_Agujeros_a_Cuerpo(j, Lista_Circulo, Boceto_X, Grupo_Temp)
		
		
		if j == 3:
			for f in range(0, len(Lista_Linea)):
				if Lista_Linea[f][3] == 'circulo' and Lista_Linea[f][9] == Grupo_Z and Lista_Linea[f][4] == Boceto_X.Label:
					if Lista02_Y[j][1] * Lista02_Y[j][2] == list(Lista_Linea[f][8])[0]:
						Lista_Circulo[j][2].append(Lista_Linea[f])
			
			# Restriccion_Agujeros_a_Cuerpo(Indice_X, Lista_Circulo, Boceto_X, Grupo_Temp):
			Restriccion_Agujeros_a_Cuerpo(j, Lista_Circulo, Boceto_X, Grupo_Temp)
	
	Plano.recompute()
	
	
	
def Fijar_Agujero_a_Arco(Boceto_X, Total_Lista_Cir, Grupo_X, Lista_Arc):
	
	Grupo_Cir = []
	
	for k in range(0, len(Lista_Linea)):
		if Lista_Linea[k][4] == Boceto_X.Label and Lista_Linea[k][9] == Grupo_X:
			Grupo_Cir.append(Lista_Linea[k])
	
	for k in range(0, Total_Lista_Cir):
		j = math.floor(k / len(Lista_Arc))
		Boceto_X.addConstraint(Sketcher.Constraint('PointOnObject', Grupo_Cir[k][0], 3, Lista_Arc[j]))
		
		
		
def Fijar_Angulo_a_Arco(Boceto_X, C_X, C_Y, Grupo_X):
	
	Grupo_Cir = []
	
	# Actualizar_Grupo(Boceto_X):
	Grupo_Y = Actualizar_Grupo(Boceto_X)
	
	for k in range(0, len(Lista_Linea)):
		if Lista_Linea[k][3] == 'circulo' and Lista_Linea[k][4] == Boceto_X.Label and Lista_Linea[k][9] == Grupo_X:
			Grupo_Cir.append(Lista_Linea[k])
	
	# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
	for j in range(0, len(Grupo_Cir)):
		# Arriba-Derecha
		if Grupo_Cir[j][8][0] > 0 and Grupo_Cir[j][8][1] > 0:
			# linea de centro a circulo
			Ang = math.atan((Grupo_Cir[j][8][1] - C_Y) / (Grupo_Cir[j][8][0] - C_X))
			Crear_Linea([C_X, C_Y, 0], Grupo_Cir[j][8], Boceto_X, Grupo_X = Grupo_Y, Guia = True)
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[-1][0], 1, 1, 3))
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[-1][0], 2, Grupo_Cir[j][0], 3))
			Boceto_X.addConstraint(Sketcher.Constraint('Angle', Lista_Linea[-1][0], Ang))
			
		# Abajo-Derecha
		if Grupo_Cir[j][8][0] > 0 and Grupo_Cir[j][8][1] < 0:
			# linea de centro a circulo
			Ang = math.atan((Grupo_Cir[j][8][1] + C_Y) / (Grupo_Cir[j][8][0] - C_X))
			Crear_Linea([C_X, -C_Y, 0], Grupo_Cir[j][8], Boceto_X, Grupo_X = Grupo_Y, Guia = True)
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[-1][0], 1, 3, 3))
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[-1][0], 2, Grupo_Cir[j][0], 3))
			Boceto_X.addConstraint(Sketcher.Constraint('Angle', Lista_Linea[-1][0], Ang))
			
		# Abajo-Izquierda
		if Grupo_Cir[j][8][0] < 0 and Grupo_Cir[j][8][1] < 0:
			# linea de circulo a centro
			Ang = math.atan((Grupo_Cir[j][8][1] + C_Y) / (Grupo_Cir[j][8][0] + C_X))
			Crear_Linea(Grupo_Cir[j][8], [-C_X, -C_Y, 0], Boceto_X, Grupo_X = Grupo_Y, Guia = True)
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[-1][0], 1, Grupo_Cir[j][0], 3))
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[-1][0], 2, 5, 3))
			Boceto_X.addConstraint(Sketcher.Constraint('Angle', Lista_Linea[-1][0], Ang))
			
		# Arriba-Izquierda
		if Grupo_Cir[j][8][0] < 0 and Grupo_Cir[j][8][1] > 0:
			# linea de circulo a centro
			Ang = math.atan((Grupo_Cir[j][8][1] - C_Y) / (Grupo_Cir[j][8][0] + C_X))
			Crear_Linea(Grupo_Cir[j][8], [-C_X, C_Y, 0], Boceto_X, Grupo_X = Grupo_Y, Guia = True)
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[-1][0], 1, Grupo_Cir[j][0], 3))
			Boceto_X.addConstraint(Sketcher.Constraint('Coincident', Lista_Linea[-1][0], 2, 7, 3))
			Boceto_X.addConstraint(Sketcher.Constraint('Angle', Lista_Linea[-1][0], Ang))
	
	
	
def Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
					Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	
	# Validamos los argumentos de la funcion
	if not type(Lista_X) is list:
		raise TypeError(f'\n\n\t Mensaje = No es Lista \n\t Funcion = Crear_Contorno \n\t {type(Lista_X) = }')
		
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Contorno \n\t {type(Boceto_X) = }')
		
	if not type(Simetria) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Contorno \n\t {type(Simetria) = }')
		
	if not type(Espejo) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Contorno \n\t {type(Espejo) = }')
		
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Contorno \n\t {type(Largo_Total) = }')
		
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Contorno \n\t {type(Alto_Total) = }')
		
	if not type(Desfase) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Contorno \n\t {type(Desfase) = }')
	
	
	# Actualizar_Grupo(Boceto_X):
	Grupo_Y = Actualizar_Grupo(Boceto_X)
	
	
	# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
	# Crear_Arco(Pt1, Eje, Radio, Boceto_X, Ang_Ini, Ang_Fin, Simetria = False, Restriccion = False, Grupo_X = 'G_001', Guia = False):
	for j in range(0, len(Lista_X)):
		if Lista_X[j][0] == 'linea':
			Crear_Linea([Lista_X[j][2], Lista_X[j][3], 0], [Lista_X[j][4], Lista_X[j][5], 0], Boceto_X, Grupo_X = Grupo_Y, Guia = Guia_X)
		if Lista_X[j][0] == 'arco':
			Crear_Arco(App.Vector(Lista_X[j][1], Lista_X[j][2], 0), Lista_X[j][3], Lista_X[j][4], Boceto_X, Lista_X[j][5], Lista_X[j][6], Grupo_X = Grupo_Y, Guia = Guia_X)
	
	# Validar_Puntos_de_Contacto(Total_Lista):
	Validar_Puntos_de_Contacto(len(Lista_X))
	
	if Simetria == False and Espejo == False:
		
		# Restriccion_Ortogonal_Linea(Boceto_X, Total_Lista, Desfase = -1):
		Restriccion_Ortogonal_Linea(Boceto_X, len(Lista_X), Desfase)
		
		# Unir_Lineas(Boceto_X, Total_Lista):
		Unir_Lineas(Boceto_X, len(Lista_X))
		
		if Largo_Total != -1:
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_Pral')
			
			# Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Valor_X, Desfase = False, Grupo_Base_X = ['G_001', 'G_002'], Titulo_Y = 'Margen_01'):
			Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Largo_Total, Titulo_Y = 'Largo_Total')
			
			# Restriccion_DistanciaY_linea(Lista_X, Boceto_X, Valor_X, Desfase = False, Grupo_Base_X = ['G_001', 'G_002'], Titulo_Y = 'Margen_01'):
			Restriccion_DistanciaY_linea(Lista_X, Boceto_X, Alto_Total, Titulo_Y = 'Alto_Total')
			
			# Simetria_Objeto_Eje(Lista_X, Boceto_X, Objeto, Eje = -1, Paso = 1):
			Simetria_Objeto_Eje(Lista_X, Boceto_X, 'arco', -1, 2)
			
		if Desfase != -1:
			
			# Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Valor_X, Desfase = False, Grupo_Base_X = ['G_001', 'G_002'], Titulo_Y = 'Margen_01'):
			Restriccion_DistanciaX_linea(Lista_X, Boceto_X, Desfase, True, Grupo_Base, Titulo_X)
			
			# Restriccion_Coincidente_Arco(Lista_X, Boceto_X, Grupo_Base_X = ['G_001', 'G_002']):
			Restriccion_Coincidente_Arco(Lista_X, Boceto_X, Grupo_Base)
			
	if Espejo == True:

		# Unir_Lineas(Boceto_X, Total_Lista):
		Unir_Lineas(Boceto_X, len(Lista_X))

		# Restriccion_Ortogonal_Linea(Boceto_X, Total_Lista, Desfase = -1):
		Restriccion_Ortogonal_Linea(Boceto_X, len(Lista_X), Desfase)
		
		# aqui colocamos las restricciones manualmente
		if Boceto_X.Label == 'B_LVS_Hoyo_P1' and Lista_Linea[-1][9] == 'G_001':
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_01', [1])
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_02', [0, 2, 3])
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('DistanceX', -1, 1, 5, 1, 1))
			constraintList.append(Sketcher.Constraint('DistanceY', 4, 2, -1, 1, 334))
			constraintList.append(Sketcher.Constraint('DistanceX', 6, 2, 1, 1, 25))
			constraintList.append(Sketcher.Constraint('DistanceY', 4, 2, 0, 1, 8))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(17, u'Alto_01')
			Boceto_X.setVirtualSpace(17, False)
			Boceto_X.setExpression('Constraints.Alto_01', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor + 18 mm : (VarSet001.Aro_Alto > 800 mm ? 400 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor + 18 mm : VarSet001.Aro_Alto / 2 + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor + 18 mm)')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(17, 'DistanceY', 4, 2, -1, 1, 334, 'Alto_01', 'G_001', 'NA', Boceto_X.Label)
			
			
		if Boceto_X.Label == 'B_LVS_Hoyo_P1' and Lista_Linea[-1][9] == 'G_002':
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_05', [1])
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_06', [0, 2, 3, 4])
			
			Grupo_Z = Actualizar_Grupo(Boceto_X)
			
			# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
			Crear_Linea([33, -321, 0], [26, -321, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			Crear_Linea([33, -321, 0], [26.937822, -317.5, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('DistanceX', -1, 1, 23, 2, 1))
			constraintList.append(Sketcher.Constraint('DistanceY', 16, 1, -1, 1, 316))
			constraintList.append(Sketcher.Constraint('DistanceY', 21, 2, 16, 1, 8))
			constraintList.append(Sketcher.Constraint('DistanceX', 22, 1, 19, 2, 25))
			constraintList.append(Sketcher.Constraint('Coincident', 18, 3, 25, 1))
			constraintList.append(Sketcher.Constraint('Coincident', 18, 3, 26, 1))
			constraintList.append(Sketcher.Constraint('Coincident', 25, 2, 18, 2))
			constraintList.append(Sketcher.Constraint('Coincident', 17, 1, 26, 2))
			constraintList.append(Sketcher.Constraint('Angle', 26, 1, 25, 1, math.radians(30)))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(59, u'Alto_03')
			Boceto_X.setVirtualSpace(59, False)
			Boceto_X.setExpression('Constraints.Alto_03', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : (VarSet001.Aro_Alto > 800 mm ? 400 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : VarSet001.Aro_Alto / 2 + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor)')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(59, 'DistanceY', 16, 1, -1, 1, 316, 'Alto_03', 'G_002', 'NA', Boceto_X.Label)
			
			
		if Boceto_X.Label == 'B_LVS_Hoyo_P2' and Lista_Linea[-1][9] == 'G_001':	
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_01')
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('DistanceY', 3, 2, 0, 1, 4))
			constraintList.append(Sketcher.Constraint('DistanceX', 1, 2, 6, 2, 35))
			constraintList.append(Sketcher.Constraint('DistanceX', -1, 1, 2, 2, 1))
			constraintList.append(Sketcher.Constraint('DistanceY', -1, 1, 3, 2, 316))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(19, u'Alto_01')
			Boceto_X.setVirtualSpace(19, False)
			Boceto_X.setExpression('Constraints.Alto_01', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : (VarSet001.Aro_Alto > 800 mm ? 400 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : VarSet001.Aro_Alto / 2 + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor)')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(19, 'DistanceY', -1, 1, 3, 2, 316, 'Alto_01', 'G_001', 'NA', Boceto_X.Label)
			
		
		if Boceto_X.Label == 'B_LVS_Hoyo_P2' and Lista_Linea[-1][9] == 'G_002':
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_03')
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('DistanceX', 6, 2, 17, 2, 2))
			constraintList.append(Sketcher.Constraint('DistanceY', 19, 2, 16, 1, 4))
			constraintList.append(Sketcher.Constraint('DistanceX', 17, 2, 22, 2, 3))
			constraintList.append(Sketcher.Constraint('DistanceY', -1, 1, 19, 2, 316))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(59, u'Alto_03')
			Boceto_X.setVirtualSpace(59, False)
			Boceto_X.setExpression('Constraints.Alto_03', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : (VarSet001.Aro_Alto > 800 mm ? 400 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : VarSet001.Aro_Alto / 2 + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor)')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(59, 'DistanceY', -1, 1, 19, 2, 316, 'Alto_03', 'G_002', 'NA', Boceto_X.Label)
			
		
	Plano.recompute()
	

	
	
	# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
	# Crear_Arco(Pt1, Eje, Radio, Boceto_X, Ang_Ini, Ang_Fin, Simetria = False, Restriccion = False, Grupo_X = 'G_001', Guia = False):
	if Simetria == True:
		#$ Objeto Simetrico en el centro
		for k in range(0, len(Lista_X)):
			if Lista_X[::-1][k][0] == 'linea':
				Crear_Linea([-Lista_X[::-1][k][2], Lista_X[::-1][k][3], 0], [-Lista_X[::-1][k][4], Lista_X[::-1][k][5], 0], Boceto_X, Simetria = True, Grupo_X = Grupo_Y, Guia = Guia_X)
			if Lista_X[::-1][k][0] == 'arco':
				Crear_Arco(App.Vector(-Lista_X[::-1][k][1], Lista_X[::-1][k][2], 0), Lista_X[::-1][k][3], Lista_X[::-1][k][4], Boceto_X, math.radians(180) - Lista_X[::-1][k][6], math.radians(180) - Lista_X[::-1][k][5], True, Grupo_X = Grupo_Y, Guia = Guia_X)
		
		# Validar_Puntos_de_Contacto(Total_Lista):
		Validar_Puntos_de_Contacto(2 * len(Lista_X))
	
	if Espejo == True:
		#$ Objeto Espejo con respecto al Origen
		for k in range(0, len(Lista_X)):
			if Lista_X[k][0] == 'linea':
				Crear_Linea([-Lista_X[k][2], Lista_X[k][3], 0], [-Lista_X[k][4], Lista_X[k][5], 0], Boceto_X, Grupo_X = Grupo_Y, Guia = Guia_X)
			if Lista_X[k][0] == 'arco':
				Crear_Arco(App.Vector(-Lista_X[k][1], Lista_X[k][2], 0), Lista_X[k][3], Lista_X[k][4], Boceto_X, math.radians(180) - Lista_X[k][6], math.radians(180) - Lista_X[k][5], Grupo_X = Grupo_Y, Guia = Guia_X)
		
		# Validar_Puntos_de_Contacto(Total_Lista):
		Validar_Puntos_de_Contacto(len(Lista_X))
	
	Plano.recompute()
	
	
	if Simetria == True:
		
		# Unir_Lineas(Boceto_X, Total_Lista):
		Unir_Lineas(Boceto_X, 2 * len(Lista_X))
		
		# Restriccion_Ortogonal_Linea(Boceto_X, Total_Lista, Desfase = -1):
		Restriccion_Ortogonal_Linea(Boceto_X, 2 * len(Lista_X))
		
		# aqui colocamos las restricciones manualmente
		if Boceto_X.Label == 'B_LVS_Pieza1' and Lista_Linea[-1][9] == 'G_001':
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, 2 * len(Lista_X), 'arco', True, 'Radio_01')
			
			Boceto_X.delConstraint(13)
			Boceto_X.delConstraint(16)
			
			Grupo_Z = Actualizar_Grupo(Boceto_X)
			
			# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
			Crear_Linea([33, -321, 0], [28, -321, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			Crear_Linea([33, -321, 0], [33, -316, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			Crear_Linea([-33, -321, 0], [-28, -321, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			Crear_Linea([-33, -321, 0], [-33, -316, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('DistanceY', 0, 1, -1, 1, 315))
			constraintList.append(Sketcher.Constraint('DistanceY', 5, 2, 0, 1, 21))
			constraintList.append(Sketcher.Constraint('PointOnObject', 0, 1, -2))
			constraintList.append(Sketcher.Constraint('PointOnObject', 5, 2, -2))
			constraintList.append(Sketcher.Constraint('DistanceY', 3, 2, 2, 2, 10))
			constraintList.append(Sketcher.Constraint('DistanceX', 5, 2, 4, 1, 23))
			constraintList.append(Sketcher.Constraint('DistanceX', 6, 1, 5, 2, 23))
			constraintList.append(Sketcher.Constraint('DistanceY', 7, 1, 8, 1, 10))
			constraintList.append(Sketcher.Constraint('Coincident', 2, 3, 12, 1))
			constraintList.append(Sketcher.Constraint('Coincident', 2, 3, 13, 1))
			constraintList.append(Sketcher.Constraint('Coincident', 2, 2, 12, 2))
			constraintList.append(Sketcher.Constraint('Coincident', 1, 2, 13, 2))
			constraintList.append(Sketcher.Constraint('Coincident', 9, 3, 14, 1))
			constraintList.append(Sketcher.Constraint('Coincident', 9, 3, 15, 1))
			constraintList.append(Sketcher.Constraint('Coincident', 8, 1, 14, 2))
			constraintList.append(Sketcher.Constraint('Coincident', 9, 2, 15, 2))
			constraintList.append(Sketcher.Constraint('Angle', 13, 1, 12, 1, math.radians(90)))
			constraintList.append(Sketcher.Constraint('Angle', 14, 1, 15, 1, math.radians(90)))
			constraintList.append(Sketcher.Constraint('Parallel', 13, 1))
			constraintList.append(Sketcher.Constraint('Parallel', 15, 10))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(20, u'Alto_01')
			Boceto_X.setVirtualSpace(20, False)
			Boceto_X.setExpression('Constraints.Alto_01', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + VarSet001.Aro_Margen + VarSet001.Aro_Grosor : (VarSet001.Aro_Alto > 800 mm ? 400 mm + VarSet001.Aro_Margen + VarSet001.Aro_Grosor : VarSet001.Aro_Alto / 2 + VarSet001.Aro_Margen + VarSet001.Aro_Grosor)')
			
			Boceto_X.renameConstraint(21, u'Alto_02')
			Boceto_X.setVirtualSpace(21, False)
			Boceto_X.setExpression('.Constraints.Alto_02', u'20 mm + VarSet001.Aro_Margen')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(20, 'DistanceY', 0, 1, -1, 1, 315, 'Alto_01', 'G_001', 'NA',    Boceto_X.Label)
			Actualizar_Lista_Restr(21, 'DistanceY', 5, 2,  0, 1,  21, 'Alto_02', 'G_001', 'G_001', Boceto_X.Label)
			
			
		if Boceto_X.Label == 'B_LVS_Pieza2' and Lista_Linea[-1][9] == 'G_001':
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, 2 * len(Lista_X), 'arco', True, 'Radio_01')
			
			Boceto_X.delConstraint(14)
			Boceto_X.delConstraint(15)
			
			Grupo_Z = Actualizar_Grupo(Boceto_X)
			
			# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
			Crear_Linea([45, 318, 0], [43, 318, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			Crear_Linea([45, 318, 0], [45, 316, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			Crear_Linea([-43, 318, 0], [-45, 318, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			Crear_Linea([-45, 318, 0], [-45, 316, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('PointOnObject', 0, 1, -2))
			constraintList.append(Sketcher.Constraint('PointOnObject', 5, 2, -2))
			
			constraintList.append(Sketcher.Constraint('Coincident', 12, 2, 2, 2))
			constraintList.append(Sketcher.Constraint('Coincident', 12, 1, 3, 3))
			constraintList.append(Sketcher.Constraint('Coincident', 13, 1, 3, 3))
			constraintList.append(Sketcher.Constraint('Coincident', 13, 2, 3, 2))
			
			constraintList.append(Sketcher.Constraint('Coincident', 14, 1, 8, 2))
			constraintList.append(Sketcher.Constraint('Coincident', 14, 2, 8, 3))
			constraintList.append(Sketcher.Constraint('Coincident', 15, 1, 8, 3))
			constraintList.append(Sketcher.Constraint('Coincident', 15, 2, 7, 1))
			
			constraintList.append(Sketcher.Constraint('Angle', 12, 1, 13, 1, math.radians(90)))
			constraintList.append(Sketcher.Constraint('Angle', 15, 1, 14, 2, math.radians(90)))
			
			constraintList.append(Sketcher.Constraint('Parallel', 13, 4))
			constraintList.append(Sketcher.Constraint('Parallel', 15, 7))
			
			constraintList.append(Sketcher.Constraint('DistanceY', -1, 1, 5, 2, 315))
			constraintList.append(Sketcher.Constraint('DistanceY', 5, 2, 0, 1, 7))
			constraintList.append(Sketcher.Constraint('DistanceX', 0, 1, 1, 1, 43))
			constraintList.append(Sketcher.Constraint('DistanceX', 9, 1, 0, 1, 43))
			constraintList.append(Sketcher.Constraint('DistanceY', 2, 2, 2, 1, 2))
			constraintList.append(Sketcher.Constraint('DistanceY', 9, 2, 9, 1, 2))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(34, u'Alto_01')
			Boceto_X.setVirtualSpace(34, False)
			Boceto_X.setExpression('Constraints.Alto_01', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + VarSet001.Aro_Margen + VarSet001.Aro_Grosor : (VarSet001.Aro_Alto > 800 mm ? 400 mm + VarSet001.Aro_Margen + VarSet001.Aro_Grosor : VarSet001.Aro_Alto / 2 + VarSet001.Aro_Margen + VarSet001.Aro_Grosor)')
			
			Boceto_X.renameConstraint(35, u'Alto_02')
			Boceto_X.setVirtualSpace(35, False)
			Boceto_X.setExpression('.Constraints.Alto_02', u'6 mm + VarSet001.Aro_Margen')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(34, 'DistanceY', -1, 1, 5, 2, 315, 'Alto_01', 'G_001', 'NA',    Boceto_X.Label)
			Actualizar_Lista_Restr(35, 'DistanceY', 5, 2,  0, 1,  7, 'Alto_02', 'G_001', 'G_001', Boceto_X.Label)
			
			
	if Espejo == True:
		
		# Unir_Lineas(Boceto_X, Total_Lista):
		Unir_Lineas(Boceto_X, len(Lista_X))
		
		# Restriccion_Ortogonal_Linea(Boceto_X, Total_Lista, Desfase = -1):
		Restriccion_Ortogonal_Linea(Boceto_X, len(Lista_X), Desfase)
		
		# aqui colocamos las restricciones manualmente
		if Boceto_X.Label == 'B_LVS_Hoyo_P1' and Lista_Linea[-1][9] == 'G_001':
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_03', [1])
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_04', [0, 2, 3])
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('DistanceX', 13, 2, -1, 1, 1))
			constraintList.append(Sketcher.Constraint('DistanceY', 12, 2, -1, 1, 334))
			constraintList.append(Sketcher.Constraint('DistanceX', 9, 2, 14, 2, 25))
			constraintList.append(Sketcher.Constraint('DistanceY', 12, 2, 8, 1, 8))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(37, u'Alto_02')
			Boceto_X.setVirtualSpace(37, False)
			Boceto_X.setExpression('Constraints.Alto_02', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor + 18 mm : (VarSet001.Aro_Alto > 800 mm ? 400 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor + 18 mm : VarSet001.Aro_Alto / 2 + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor + 18 mm)')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(37, 'DistanceY', 12, 2, -1, 1, 334, 'Alto_02', 'G_001', 'NA', Boceto_X.Label)
			
		
		if Boceto_X.Label == 'B_LVS_Hoyo_P1' and Lista_Linea[-1][9] == 'G_002':
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_07', [1])
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_08', [0, 2, 3, 4])
			
			
			Grupo_Z = Actualizar_Grupo(Boceto_X)
			
			# Crear_Linea(Pt1, Pt2, Boceto_X, Restriccion_X = '', Simetria = False, Grupo_X = 'G_001', Guia = False):
			Crear_Linea([-33, -321, 0], [-26, -321, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			Crear_Linea([-33, -321, 0], [-26.937822, -317.5, 0], Boceto_X, Grupo_X = Grupo_Z, Guia = True)
			
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('DistanceX', 34, 2, -1, 1, 1))
			constraintList.append(Sketcher.Constraint('DistanceY', 27, 1, -1, 1, 316))
			constraintList.append(Sketcher.Constraint('DistanceY', 32, 2, 27, 1, 8))
			constraintList.append(Sketcher.Constraint('DistanceX', 30, 2, 33, 2, 25))
			constraintList.append(Sketcher.Constraint('Coincident', 36, 1, 29, 3))
			constraintList.append(Sketcher.Constraint('Coincident', 37, 1, 29, 3))
			constraintList.append(Sketcher.Constraint('Coincident', 36, 2, 29, 1))
			constraintList.append(Sketcher.Constraint('Coincident', 37, 2, 28, 2))
			constraintList.append(Sketcher.Constraint('Angle', 36, 1, 37, 1, math.radians(30)))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(86, u'Alto_04')
			Boceto_X.setVirtualSpace(86, False)
			Boceto_X.setExpression('Constraints.Alto_04', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : (VarSet001.Aro_Alto > 800 mm ? 400 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : VarSet001.Aro_Alto / 2 + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor)')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(86, 'DistanceY', 27, 1, -1, 1, 316, 'Alto_04', 'G_002', 'NA', Boceto_X.Label)
			
		if Boceto_X.Label == 'B_LVS_Hoyo_P2' and Lista_Linea[-1][9] == 'G_001':
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_02')
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('DistanceY', 11, 1, 8, 1, 4))
			constraintList.append(Sketcher.Constraint('DistanceX', 14, 2, 9, 1, 35))
			constraintList.append(Sketcher.Constraint('DistanceX', 10, 2, -1, 1, 1))
			constraintList.append(Sketcher.Constraint('DistanceY', -1, 1, 11, 1, 316))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(39, u'Alto_02')
			Boceto_X.setVirtualSpace(39, False)
			Boceto_X.setExpression('Constraints.Alto_02', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : (VarSet001.Aro_Alto > 800 mm ? 400 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : VarSet001.Aro_Alto / 2 + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor)')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(39, 'DistanceY', -1, 1, 11, 1, 316, 'Alto_02', 'G_001', 'NA', Boceto_X.Label)
			
		
		if Boceto_X.Label == 'B_LVS_Hoyo_P2' and Lista_Linea[-1][9] == 'G_002':
			
			# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
			Restriccion_Igual_Arco(Boceto_X, len(Lista_X), 'arco', True, 'Radio_04')
			
			constraintList = []
			constraintList.append(Sketcher.Constraint('DistanceX', 25, 1, 14, 2, 2))
			constraintList.append(Sketcher.Constraint('DistanceY', 27, 1, 24, 1, 4))
			constraintList.append(Sketcher.Constraint('DistanceX', 30, 2, 25, 1, 3))
			constraintList.append(Sketcher.Constraint('DistanceY', -1, 1, 27, 1, 316))
			
			Boceto_X.addConstraint(constraintList)
			
			del constraintList
			
			Boceto_X.renameConstraint(79, u'Alto_04')
			Boceto_X.setVirtualSpace(79, False)
			Boceto_X.setExpression('Constraints.Alto_04', u'VarSet001.Aro_Alto < 2 * VarSet001.Aro_Radio + 50 mm ? VarSet001.Aro_Radio + 25 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : (VarSet001.Aro_Alto > 800 mm ? 400 mm + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor : VarSet001.Aro_Alto / 2 + 2 * VarSet001.Aro_Margen + VarSet001.Aro_Grosor)')
			
			# Actualizar_Lista_Restr(ID, Nom_Obj, Obj01_ID, P01 = 'NA', Obj02_ID = 'NA', P02 = 'NA', Magnitud = 0, Nom_Restr = 'Rad', Gr01 = 'G_001', Gr02 = 'NA', Nom_Cont = 'Body'):
			Actualizar_Lista_Restr(79, 'DistanceY', -1, 1, 27, 1, 316, 'Alto_04', 'G_002', 'NA', Boceto_X.Label)
			
		
		
	Plano.recompute()
	

def Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, 
					Separacion = 76, Inicio_Centro = False, Incluir_Arco = False, Grupo_Base = ['', ''], Titulo_X = 'Radio'):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Radio_Pral) = }')
	
	if not str(type(Boceto_X)) in ("<class 'Sketcher.SketchObject'>"):
		raise TypeError(f'\n\n\t Mensaje = No es un contenedor Sketch \n\t Funcion = Crear_Agujeros \n\t {type(Boceto_X) = }')
	
	if not type(Radio_Agujero) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Radio_Agujero) = }')
		
	if not type(Separacion) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Agujeros \n\t {type(Separacion) = }')
	
	if not type(Inicio_Centro) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Agujeros \n\t {type(Inicio_Centro) = }')
		
	if not type(Incluir_Arco) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Booleano \n\t Funcion = Crear_Agujeros \n\t {type(Incluir_Arco) = }')
	
	
	# Actualizar_Grupo(Boceto_X):
	Grupo_Y = Actualizar_Grupo(Boceto_X)
		
	
	Separacion = Separacion / 2
	Val_X = (Largo_Total / 2) + 1 + 14 / 2
	Val_Y = (Alto_Total / 2) + 1 + 14 / 2
	Delta_X = (Largo_Total - 2 * Radio_Pral) / 2
	Delta_Y = (Alto_Total - 2 * Radio_Pral) / 2
	Multi_X = math.floor(Delta_X / Separacion)
	Multi_Y = math.floor(Delta_Y / Separacion)
	
	if Multi_X == 0:
		if Inicio_Centro == True:
			DeltaVal_X = [0]
		else:
			DeltaVal_X = [Delta_X]
	elif Multi_X == 1:
		if Inicio_Centro == True:
			DeltaVal_X = [0]
		else:
			DeltaVal_X = [Separacion]
	elif Multi_X == 2:
		if Inicio_Centro == True:
			DeltaVal_X = [0, Separacion * 2]
		else:
			DeltaVal_X = [Separacion]
	else:
		if Inicio_Centro == True:
			Multi_X = math.floor((Delta_X - 2 * Separacion) / (Separacion * 2))
			DeltaVal_X = [0, Separacion * 2]
			Ciclo = Separacion * 2
			for k in range(Multi_X):
				Ciclo += Separacion * 2
				DeltaVal_X.append(Ciclo)
		else:
			Multi_X = math.floor((Delta_X - Separacion) / (Separacion * 2))
			DeltaVal_X = [Separacion]
			Ciclo = Separacion
			for k in range(Multi_X):
				Ciclo += Separacion * 2
				DeltaVal_X.append(Ciclo)
			if math.floor(((Delta_X - Separacion) - Separacion * 2 * Multi_X) / Separacion) >= 1:
				DeltaVal_X.append(Delta_X)
			
	if Multi_Y == 0:
		if Inicio_Centro == True:
			DeltaVal_Y = [0]
		else:
			DeltaVal_Y = [Delta_Y]
	elif Multi_Y == 1:
		if Inicio_Centro == True:
			DeltaVal_Y = [0]
		else:
			DeltaVal_Y = [Separacion]
	elif Multi_Y == 2:
		if Inicio_Centro == True:
			DeltaVal_Y = [0, Separacion * 2]
		else:
			DeltaVal_Y = [Separacion]
	else:
		if Inicio_Centro == True:
			Multi_Y = math.floor((Delta_Y - 2 * Separacion) / (Separacion * 2))
			DeltaVal_Y = [0, Separacion * 2]
			Ciclo = Separacion * 2
			for k in range(Multi_Y):
				Ciclo += Separacion * 2
				DeltaVal_Y.append(Ciclo)
		else:
			Multi_Y = math.floor((Delta_Y - Separacion) / (Separacion * 2))
			DeltaVal_Y = [Separacion]
			Ciclo = Separacion
			for k in range(Multi_Y):
				Ciclo += Separacion * 2
				DeltaVal_Y.append(Ciclo)
			if math.floor(((Delta_Y - Separacion) - Separacion * 2 * Multi_Y) / Separacion) >= 1:
				DeltaVal_Y.append(Delta_Y)
	
	
	# Actualizar_Lista02(Val_X, Val_Y):
	Lista02 = Actualizar_Lista02(Val_X, Val_Y)
	
	# Actualizar_Lineal_Lista03(Lista02, DeltaVal_X, DeltaVal_Y, Radio_Agujero, Inicio_Centro = False):
	Lista03 = Actualizar_Lineal_Lista03(Lista02, DeltaVal_X, DeltaVal_Y, Radio_Agujero, Inicio_Centro)
	
	for k in range(0, len(Lista03)):
		# Crear_Circulo(Pt1, Eje, Radio, Boceto_X, Restriccion = True, Grupo_X = 'G_001', Guia = False):
		Crear_Circulo(Lista03[k][0], Lista03[k][1], Lista03[k][2], Boceto_X, False, Grupo_Y)
	
	# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
	Restriccion_Igual_Arco(Boceto_X, len(Lista03), Obj_X = 'circulo', Restriccion = True, Titulo = Titulo_X)
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Total, Alto_Total, Radio_Pral)
	
	# Fijar_Agujeros_a_Cuerpo(Lista01_X, Lista02_X, Boceto_X, Grupo_X, Grupo_Y):
	Fijar_Agujeros_a_Cuerpo(Lista01, Lista02, Boceto_X, Grupo_Base[0], Grupo_Base[1])
	
	Plano.recompute()
	
	if Incluir_Arco == True:
		
		Lista03 = []
		
		# Actualizar_Grupo(Boceto_X):
		Grupo_Y = Actualizar_Grupo(Boceto_X)
		
		# Actualizar_Polar_Lista03(Lista02, Delta_X, Delta_Y, Radio_Agujero, Lista03 = []):
		Lista03 = Actualizar_Polar_Lista03(Lista02, Delta_X, Delta_Y, Radio_Agujero, Lista03)
		
		for k in range(0, len(Lista03)):
			# Crear_Circulo(Pt1, Eje, Radio, Boceto_X, Restriccion = True, Grupo_X = 'G_001', Guia = False):
			Crear_Circulo(Lista03[k][0], Lista03[k][1], Lista03[k][2], Boceto_X, False, Grupo_Y)
			
		# Restriccion_Igual_Arco(Boceto_X, Total_Lista, Obj_X = 'arco', Restriccion = False, Titulo = 'Radio_Pral', Omitir = [-1]):
		Restriccion_Igual_Arco(Boceto_X, len(Lista03), Obj_X = 'circulo', Restriccion = True, Titulo = Titulo_X)
		
		# aqui creamos las lineas de soporte para anclar los circulos
		
		# centro_arco
		Cx = Delta_X
		Cy = Delta_Y
		Ra = App.Units.Quantity(Variable_H1.Aro_Radio + Variable_H1.Aro_Margen + Variable_H1.Aro_Grosor).Value
		
		Grupo_Z = Actualizar_Grupo(Boceto_X)
		
		# Crear_Arco(Pt1, Eje, Radio, Boceto_X, Ang_Ini, Ang_Fin, Simetria = False, Restriccion = False, Grupo_X = 'G_001', Guia = False):
		Crear_Arco(App.Vector(Cx, Cy, 0), App.Vector(0, 0, 1), Ra, Boceto_X, math.radians(0), math.radians(90), Grupo_X = Grupo_Z, Guia = True)
		Crear_Arco(App.Vector(-Cx, Cy, 0), App.Vector(0, 0, 1), Ra, Boceto_X, math.radians(90), math.radians(180), Grupo_X = Grupo_Z, Guia = True)
		Crear_Arco(App.Vector(-Cx, -Cy, 0), App.Vector(0, 0, 1), Ra, Boceto_X, math.radians(180), math.radians(270), Grupo_X = Grupo_Z, Guia = True)
		Crear_Arco(App.Vector(Cx, -Cy, 0), App.Vector(0, 0, 1), Ra, Boceto_X, math.radians(270), math.radians(360), Grupo_X = Grupo_Z, Guia = True)
		
		
		constraintList = []
		constraintList.append(Sketcher.Constraint('Coincident', 72, 3, 1, 3))
		constraintList.append(Sketcher.Constraint('Coincident', 73, 3, 7, 3))
		constraintList.append(Sketcher.Constraint('Coincident', 74, 3, 5, 3))
		constraintList.append(Sketcher.Constraint('Coincident', 75, 3, 3, 3))
		constraintList.append(Sketcher.Constraint('Symmetric', 9, 1, 17, 1, 72, 1))
		constraintList.append(Sketcher.Constraint('PointOnObject', 72, 2, 45))
		constraintList.append(Sketcher.Constraint('Symmetric', 16, 1, 8, 1, 73, 1))
		constraintList.append(Sketcher.Constraint('PointOnObject', 73, 2, 54))
		constraintList.append(Sketcher.Constraint('Symmetric', 21, 1, 13, 1, 74, 1))
		constraintList.append(Sketcher.Constraint('PointOnObject', 74, 2, 51))
		constraintList.append(Sketcher.Constraint('Symmetric', 11, 1, 19, 1, 75, 1))
		constraintList.append(Sketcher.Constraint('PointOnObject', 75, 2, 48))
		
		Boceto_X.addConstraint(constraintList)
			
		del constraintList
		
		# Fijar_Agujero_a_Arco(Boceto_X, Total_Lista_Cir, Grupo_X, Lista_Arc):
		Fijar_Agujero_a_Arco(Boceto_X, len(Lista03), 'G_006', [72, 75, 74, 73])
		
		# Fijar_Angulo_a_Arco(Boceto_X, C_X, C_Y, Grupo_X):
		Fijar_Angulo_a_Arco(Boceto_X, Delta_X, Delta_Y, 'G_006')
		
		
		

def Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista01 \n\t {type(Largo_X) = }')
	
	if not type(Alto_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista01 \n\t {type(Alto_X) = }')
		
	if not type(Radio_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista01 \n\t {type(Radio_X) = }')
	
	
	# Contorno circular
	Lista01 = [
		['linea', 'Horizontal', -(Largo_X - 2 * Radio_X) / 2, Alto_X / 2, (Largo_X - 2 * Radio_X) / 2, Alto_X / 2],
		['arco', (Largo_X - 2 * Radio_X) / 2, (Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(0), math.radians(90)],
		['linea', 'Vertical', Largo_X / 2, (Alto_X - 2 * Radio_X) / 2, Largo_X / 2, -(Alto_X - 2 * Radio_X) / 2],
		['arco', (Largo_X - 2 * Radio_X) / 2, -(Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(270), math.radians(360)],
		['linea', 'Horizontal', (Largo_X - 2 * Radio_X) / 2, -Alto_X / 2, -(Largo_X - 2 * Radio_X) / 2, -Alto_X / 2],
		['arco', -(Largo_X - 2 * Radio_X) / 2, -(Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(180), math.radians(270)],
		['linea', 'Vertical', -Largo_X / 2, -(Alto_X - 2 * Radio_X) / 2, -Largo_X / 2, (Alto_X - 2 * Radio_X) / 2],
		['arco', -(Largo_X - 2 * Radio_X) / 2, (Alto_X - 2 * Radio_X) / 2, App.Vector(0, 0, 1), Radio_X, math.radians(90), math.radians(180)]
	]
	return Lista01


def Actualizar_Lista02(Val_X, Val_Y):
	
	# Validamos los argumentos de la funcion
	if not type(Val_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista02 \n\t {type(Val_X) = }')
	
	if not type(Val_Y) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lista02 \n\t {type(Val_Y) = }')
	
	
	# Ubicacion de los agujeros
	Lista02 = [
		['Arriba',     1, Val_Y, 'Derecha',    1, Val_X],
		['Derecha',    1, Val_X, 'Arriba',     1, Val_Y],
		['Derecha',    1, Val_X, 'Abajo',     -1, Val_Y],
		['Abajo',     -1, Val_Y, 'Derecha',    1, Val_X],
		['Abajo',     -1, Val_Y, 'Izquierda', -1, Val_X],
		['Izquierda', -1, Val_X, 'Abajo',     -1, Val_Y],
		['Izquierda', -1, Val_X, 'Arriba',     1, Val_Y],
		['Arriba',     1, Val_Y, 'Izquierda', -1, Val_X]
	]
	
	return Lista02
	
	
def Actualizar_Lineal_Lista03(Lista02, DeltaVal_X, DeltaVal_Y, Radio_Agujero, Inicio_Centro = False):
	
	'''
	Nota:
		Lista02: Es la lista que se usara para indicar la direccion en que se dibujaran los circulos
		DeltaVal_X: Es la lista de las separaciones de los centros de los circulos en el eje X
		DeltaVal_Y: Es la lista de las separaciones de los centros de los circulos en el eje Y
		Radio_Agujero: Es el radio del circulo a dibujar
		Inicio_Centro: Es la opcion de separar el primer circulo del punto de inicio
	'''
	
	# Validamos los argumentos de la funcion
	if not type(Lista02) is list:
		raise TypeError(f'\n\n\t Mensaje = No es una Lista \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(Lista02) = }')
		
	if not type(DeltaVal_X) is list:
		raise TypeError(f'\n\n\t Mensaje = No es una Lista \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(DeltaVal_X) = }')
		
	if not type(DeltaVal_Y) is list:
		raise TypeError(f'\n\n\t Mensaje = No es una Lista \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(DeltaVal_Y) = }')
	
	if not type(Radio_Agujero) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(Radio_Agujero) = }')
		
	if not type(Inicio_Centro) is bool:
		raise TypeError(f'\n\n\t Mensaje = No es Bolleano \n\t Funcion = Actualizar_Lineal_Lista03 \n\t {type(Inicio_Centro) = }')
	
	
	# Ubicacion de lo agujeros con vectores
	Lista03 = []
	for j in range(0, len(Lista02)):
		
		if (Lista02[j][3] == 'Derecha' or Lista02[j][3] == 'Abajo') and Inicio_Centro == True:
			Val_Ini = 1
		else:
			Val_Ini = 0
		
		if Lista02[j][0] == 'Arriba':
			for k in range(Val_Ini, len(DeltaVal_X)):
				Lista_Temp = [App.Vector(Lista02[j][4] * DeltaVal_X[k], Lista02[j][1] * Lista02[j][2], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Abajo':
			for k in range(Val_Ini, len(DeltaVal_X)):
				Lista_Temp = [App.Vector(Lista02[j][4] * DeltaVal_X[k], Lista02[j][1] * Lista02[j][2], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Derecha':
			for k in range(Val_Ini, len(DeltaVal_Y)):
				Lista_Temp = [App.Vector(Lista02[j][1] * Lista02[j][2],Lista02[j][4] * DeltaVal_Y[k], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Izquierda':
			for k in range(Val_Ini, len(DeltaVal_Y)):
				Lista_Temp = [App.Vector(Lista02[j][1] * Lista02[j][2],Lista02[j][4] * DeltaVal_Y[k], 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
	
	return Lista03
	
	
def Actualizar_Polar_Lista03(Lista02, Delta_X, Delta_Y, Radio_Agujero, Lista03 = []):
	
	'''
	Nota:
		Lista02: Es la lista que se usara para indicar la direccion en que se dibujaran los circulos
		DeltaVal_X: Es la lista de las separaciones de los centros de los circulos en el eje X
		DeltaVal_Y: Es la lista de las separaciones de los centros de los circulos en el eje Y
		Radio_Agujero: Es el radio del circulo a dibujar
	'''
	# Validamos los argumentos de la funcion
	if not type(Lista02) is list:
		raise TypeError(f'\n\n\t Mensaje = No es una Lista \n\t Funcion = Actualizar_Polar_Lista03 \n\t {type(Lista02) = }')
		
	if not type(Delta_X) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Polar_Lista03 \n\t {type(Delta_X) = }')
		
	if not type(Delta_Y) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Polar_Lista03 \n\t {type(Delta_Y) = }')
	
	if not type(Radio_Agujero) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Actualizar_Polar_Lista03 \n\t {type(Radio_Agujero) = }')
	
	
	
	# Ubicacion de lo agujeros con vectores
	Margen = 12
	Separacion = 38
	Radio_Eje = Lista02[1][5] - Delta_X
	Angulo_Delta = Separacion / Radio_Eje
	Cuerda_Eje = Radio_Eje * math.radians(90) / 2 - Margen
	Total_Circulo01 = 1 + 2 * math.floor(Cuerda_Eje / Separacion)
	Total_Circulo02 = 2 + 2 * math.floor((Cuerda_Eje - Separacion / 2) / Separacion)
	Angulo_Ini01 = math.radians(45) - (Total_Circulo01 - 1) * Angulo_Delta / 2
	Angulo_Ini02 = math.radians(45) - (Total_Circulo02 - 1) * Angulo_Delta / 2
	
	
	if Total_Circulo01 > Total_Circulo02:
		Total_Circulo03 = Total_Circulo01
		Angulo_Ini03 = Angulo_Ini01
	else:
		Total_Circulo03 = Total_Circulo02
		Angulo_Ini03 = Angulo_Ini02
	
		
	for j in range(0, len(Lista02)):
		
		if Lista02[j][0] == 'Arriba' and Lista02[j][3] == 'Derecha':
			for k in range(0, Total_Circulo03):
				Lista_Temp = [App.Vector(Lista02[j][4] * Lista02[j][5] - Radio_Eje * (1 - math.cos(Angulo_Ini03 + k * Angulo_Delta)), Lista02[j][1] * Delta_Y + Radio_Eje * math.sin(Angulo_Ini03 + k * Angulo_Delta), 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Arriba' and Lista02[j][3] == 'Izquierda':
			for k in range(0, Total_Circulo03):
				Lista_Temp = [App.Vector(Lista02[j][4] * Lista02[j][5] + Radio_Eje * (1 - math.cos(Angulo_Ini03 + k * Angulo_Delta)), Lista02[j][1] * Delta_Y + Radio_Eje * math.sin(Angulo_Ini03 + k * Angulo_Delta), 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Abajo' and Lista02[j][3] == 'Derecha':
			for k in range(0, Total_Circulo03):
				Lista_Temp = [App.Vector(Lista02[j][4] * Lista02[j][5] - Radio_Eje * (1 - math.cos(Angulo_Ini03 + k * Angulo_Delta)), Lista02[j][1] * Delta_Y - Radio_Eje * math.sin(Angulo_Ini03 + k * Angulo_Delta), 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		elif Lista02[j][0] == 'Abajo' and Lista02[j][3] == 'Izquierda':
			for k in range(0, Total_Circulo03):
				Lista_Temp = [App.Vector(Lista02[j][4] * Lista02[j][5] + Radio_Eje * (1 - math.cos(Angulo_Ini03 + k * Angulo_Delta)), Lista02[j][1] * Delta_Y - Radio_Eje * math.sin(Angulo_Ini03 + k * Angulo_Delta), 0), App.Vector(0, 0, 1), Radio_Agujero]
				Lista03.append(Lista_Temp)
		
	return Lista03
	
	
	
def Limpiar_Pantalla():
	
	mw = Gui.getMainWindow()
	
	rv = mw.findChild(QtGui.QTextEdit, "Report view")
	rv.clear()
	
	pc = mw.findChild(QtGui.QPlainTextEdit,"Python console")
	pc.onClearConsole()
	











#! crear Boceto Cuerpo
def Crear_Boceto_Cuerpo(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Cuerpo \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Cuerpo \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Cuerpo \n\t {type(Radio_Pral) = }')
	
	
	Largo_Y = Largo_Total
	Alto_Y = Alto_Total
	Radio_Y = Radio_Pral
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_C, Largo_Total = Largo_Y, Alto_Total = Alto_Y)
	
	
	Largo_Y += 1 + 1
	Alto_Y += 1 + 1
	Radio_Y += 1
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_C, Desfase = 1, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01')
	
	
	Largo_Y += 14 + 14
	Alto_Y += 14 + 14
	Radio_Y += 14
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_C, Desfase = 14, Grupo_Base = ['G_002', 'G_003'], Titulo_X = 'Grosor_01')
	
	
	Largo_Y += 1 + 1
	Alto_Y += 1 + 1
	Radio_Y += 1
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_C, Desfase = 1, Grupo_Base = ['G_003', 'G_004'], Titulo_X = 'Margen_02')
	
	
	# Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, 
	# Separacion = 76, Inicio_Centro = False, Incluir_Arco = False, Grupo_Base = ['', ''], Titulo_X = 'Radio'):
	Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_LVS_C, 1.5, Grupo_Base = ['G_002', 'G_003'], Titulo_X = 'Hoyo_01')
	


#! crear Boceto Tapadera
def Crear_Boceto_Tapadera(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Tapadera \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Tapadera \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Tapadera \n\t {type(Radio_Pral) = }')
	
	
	Largo_Y = Largo_Total
	Alto_Y = Alto_Total
	Radio_Y = Radio_Pral
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_T, Largo_Total = Largo_Y, Alto_Total = Alto_Y, Guia_X = True)
	
	
	Largo_Y += 0.5 + 0.5
	Alto_Y += 0.5 + 0.5
	Radio_Y += 0.5
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_T, Desfase = 0.5, Guia_X = True, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Desfase_01')
	
	
	Largo_Y += 1 + 1
	Alto_Y += 1 + 1
	Radio_Y += 1
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_T, Desfase = 1, Grupo_Base = ['G_002', 'G_003'], Titulo_X = 'Margen_01')
	
	
	Largo_Y += 13 + 13
	Alto_Y += 13 + 13
	Radio_Y += 13
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_T, Desfase = 13, Grupo_Base = ['G_003', 'G_004'], Titulo_X = 'Tapadera_01')
	
	
	# Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, 
	# Separacion = 76, Inicio_Centro = False, Incluir_Arco = False, Grupo_Base = ['', ''], Titulo_X = 'Radio'):
	Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_LVS_T, 1.5, Grupo_Base = ['G_003', 'G_004'], Titulo_X = 'Hoyo_01')
	
	

#! crear Boceto Pieza 1
def Crear_Boceto_P1(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P1 \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P1 \n\t {type(Alto_Total) = }')
	
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P1 \n\t {type(Radio_Pral) = }')
	
	
	Origen_Y = -(Alto_Total / 2) - 15
	Origen_X = 0
	
	if ((Largo_Total - 2 * Radio_Pral) / 2) >= 33:
	
		Lista04 = [
			['linea', 'Horizontal', Origen_X, Origen_Y, Origen_X + 33, Origen_Y],
			['linea', 'Vertical', Origen_X + 33, Origen_Y, Origen_X + 33, Origen_Y - 1],
			['arco', Origen_X + 33, Origen_Y - 6, App.Vector(0, 0, 1), 5, math.radians(90), math.radians(180)],
			['linea', 'Vertical', Origen_X + 28, Origen_Y - 6, Origen_X + 28, Origen_Y - 16],
			['arco', Origen_X + 23, Origen_Y - 16, App.Vector(0, 0, 1), 5, math.radians(270), math.radians(360)],
			['linea', 'Horizontal', Origen_X + 23, Origen_Y - 21, Origen_X, Origen_Y - 21]
		]
	
	else:
		
		Desfase_X = 33 - (Largo_Total - 2 * Radio_Pral) / 2
		Radio_CC = Radio_Pral + (1 + 14 + 1) + 5
		Desfase_Y = Radio_CC - math.sqrt(Radio_CC**2 - Desfase_X**2)
		Angulo_Desfase = math.acos(Desfase_X / Radio_CC)
		
		Lista04 = [
			['linea', 'Horizontal', Origen_X, Origen_Y - 21, Origen_X + 23, Origen_Y - 21],
			['arco', Origen_X + 23, Origen_Y - 16, App.Vector(0, 0, 1), 5, math.radians(270), math.radians(360)],
			['linea', 'Vertical', Origen_X + 28, Origen_Y - 16, Origen_X + 28, Origen_Y - 6 + Desfase_Y],
			['arco', Origen_X + 33, Origen_Y - 6 + Desfase_Y, App.Vector(0, 0, 1), 5, math.radians(180) - Angulo_Desfase, math.radians(180)],
			['linea', 'Oblicua', Origen_X + 33 - 5 * math.cos(Angulo_Desfase), Origen_Y - 6 + Desfase_Y + 5 * math.sin(Angulo_Desfase), Origen_X + 33 - 6 * math.cos(Angulo_Desfase), Origen_Y - 6 + Desfase_Y + 6 * math.sin(Angulo_Desfase)],
			['arco', (Largo_Total - 2 * Radio_Pral) / 2, -(Alto_Total - 2 * Radio_Pral) / 2, App.Vector(0, 0, 1), Radio_CC - 6, math.radians(270), math.radians(360) - Angulo_Desfase],
			['linea', 'Horizontal', (Largo_Total - 2 * Radio_Pral) / 2, Origen_Y, Origen_X, Origen_Y]
		]
		
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista04, Boceto_LVS_P1, Simetria = True)
	
	
	
	#$ crear Boceto Hoyo Pieza 1
	Lista05 = [
		['linea', 'Horizontal', Origen_X + 2, Origen_Y - 11, Origen_X + 25, Origen_Y - 11],
		['arco', Origen_X + 25, Origen_Y - 12, App.Vector(0, 0, 1), 1, math.radians(0), math.radians(90)],
		['linea', 'Vertical', Origen_X + 26, Origen_Y - 12, Origen_X + 26, Origen_Y - 16],
		['arco', Origen_X + 23, Origen_Y - 16, App.Vector(0, 0, 1), 3, math.radians(270), math.radians(360)],
		['linea', 'Horizontal', Origen_X + 23, Origen_Y - 19, Origen_X + 2, Origen_Y - 19],
		['arco', Origen_X + 2, Origen_Y - 18, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
		['linea', 'Vertical', Origen_X + 1, Origen_Y - 18, Origen_X + 1, Origen_Y - 12],
		['arco', Origen_X + 2, Origen_Y - 12, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista05, Boceto_LVS_H_P1, Espejo = True)
	
	
	
	
	Lista06 = [
		['linea', 'Horizontal', Origen_X + 2, Origen_Y - 1, Origen_X + 33 - 4 * math.sqrt(3), Origen_Y - 1],
		['arco', Origen_X + 33 - 4 * math.sqrt(3), Origen_Y - 2, App.Vector(0, 0, 1), 1, math.radians(-30), math.radians(90)],
		['arco', Origen_X + 33, Origen_Y - 6, App.Vector(0, 0, 1), 7, math.radians(150), math.radians(180)],
		['linea', 'Vertical', Origen_X + 26, Origen_Y - 6, Origen_X + 26, Origen_Y - 8],
		['arco', Origen_X + 25, Origen_Y - 8, App.Vector(0, 0, 1), 1, math.radians(270), math.radians(360)],
		['linea', 'Horizontal', Origen_X + 25, Origen_Y - 9, Origen_X + 2, Origen_Y - 9],
		['arco', Origen_X + 2, Origen_Y - 8, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
		['linea', 'Vertical', Origen_X + 1, Origen_Y - 8, Origen_X + 1, Origen_Y - 2],
		['arco', Origen_X + 2, Origen_Y - 2, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista06, Boceto_LVS_H_P1, Espejo = True)
	
	

#! crear Boceto Pieza 2
def Crear_Boceto_P2(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P2 \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P2 \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_P2 \n\t {type(Radio_Pral) = }')
	
	Origen_Y = (Alto_Total / 2) + 15
	Origen_X = 0
	
	if ((Largo_Total - 2 * Radio_Pral) / 2) > 45:
	
		Lista07 = [
			['linea', 'Horizontal', Origen_X, Origen_Y + 7, Origen_X + 41, Origen_Y + 7],
			['arco', Origen_X + 41, Origen_Y + 5, App.Vector(0, 0, 1), 2, math.radians(0), math.radians(90)],
			['linea', 'Vertical', Origen_X + 43, Origen_Y + 5, Origen_X + 43, Origen_Y + 3],
			['arco', Origen_X + 45, Origen_Y + 3, App.Vector(0, 0, 1), 2, math.radians(180), math.radians(270)],
			['linea', 'Vertical', Origen_X + 45, Origen_Y + 1, Origen_X + 45, Origen_Y],
			['linea', 'Horizontal', Origen_X + 45, Origen_Y, Origen_X, Origen_Y]
		]
		
	else:
		
		Desfase_X = 45 - (Largo_Total - 2 * Radio_Pral) / 2
		Radio_CC = Radio_Pral + (1 + 14 + 1) + 2
		Desfase_Y = Radio_CC - math.sqrt(Radio_CC**2 - Desfase_X**2)
		Angulo_Desfase = math.acos(Desfase_X / Radio_CC)
		
		Lista07 = [
			['linea', 'Horizontal', Origen_X, Origen_Y + 7, Origen_X + 41, Origen_Y + 7],
			['arco', Origen_X + 41, Origen_Y + 5, App.Vector(0, 0, 1), 2, math.radians(0), math.radians(90)],
			['linea', 'Vertical', Origen_X + 43, Origen_Y + 5, Origen_X + 43, Origen_Y + 3 - Desfase_Y],
			['arco', Origen_X + 45, Origen_Y + 3 - Desfase_Y, App.Vector(0, 0, 1), 2, math.radians(180), math.radians(180) + Angulo_Desfase],
			['linea', 'Oblicua', Origen_X + 45 - 2 * math.cos(Angulo_Desfase), Origen_Y + 3 - Desfase_Y - 2 * math.sin(Angulo_Desfase), Origen_X + 45 - 3 * math.cos(Angulo_Desfase), Origen_Y + 3 - Desfase_Y - 3 * math.sin(Angulo_Desfase)],
			['arco', (Largo_Total - 2 * Radio_Pral) / 2, (Alto_Total - 2 * Radio_Pral) / 2, App.Vector(0, 0, 1), Radio_CC - 3, Angulo_Desfase, math.radians(90)],
			['linea', 'Horizontal', (Largo_Total - 2 * Radio_Pral) / 2, Origen_Y, Origen_X, Origen_Y]
		]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista07, Boceto_LVS_P2, Simetria = True)
	
	
	
	
	#$ crear Boceto Hoyo Pieza 2
	Lista08 = [
		['linea', 'Horizontal', Origen_X + 2, Origen_Y + 5, Origen_X + 35, Origen_Y + 5],
		['arco', Origen_X + 2, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)],
		['linea', 'Vertical', Origen_X + 1, Origen_Y + 4, Origen_X + 1, Origen_Y + 2],
		['arco', Origen_X + 2, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
		['linea', 'Horizontal', Origen_X + 2, Origen_Y + 1, Origen_X + 35, Origen_Y + 1],
		['arco', Origen_X + 35, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(270), math.radians(360)],
		['linea', 'Vertical', Origen_X + 36, Origen_Y + 2, Origen_X + 36, Origen_Y + 4],
		['arco', Origen_X + 35, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(0), math.radians(90)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista08, Boceto_LVS_H_P2, Espejo = True)
	
	
	Lista09 = [
		['linea', 'Horizontal', Origen_X + 39, Origen_Y + 5, Origen_X + 40, Origen_Y + 5],
		['arco', Origen_X + 39, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(90), math.radians(180)],
		['linea', 'Vertical', Origen_X + 38, Origen_Y + 4, Origen_X + 38, Origen_Y + 2],
		['arco', Origen_X + 39, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(180), math.radians(270)],
		['linea', 'Horizontal', Origen_X + 39, Origen_Y + 1, Origen_X + 40, Origen_Y + 1],
		['arco', Origen_X + 40, Origen_Y + 2, App.Vector(0, 0, 1), 1, math.radians(270), math.radians(360)],
		['linea', 'Vertical', Origen_X + 41, Origen_Y + 2, Origen_X + 41, Origen_Y + 4],
		['arco', Origen_X + 40, Origen_Y + 4, App.Vector(0, 0, 1), 1, math.radians(0), math.radians(90)]
	]
	
	
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista09, Boceto_LVS_H_P2, Espejo = True)
	
	
	


#! Crear_Boceto_Iman
def Crear_Boceto_Iman(Largo_Total, Alto_Total, Radio_Pral):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Iman \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Iman \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Boceto_Iman \n\t {type(Radio_Pral) = }')
	
	
	Largo_Y = Largo_Total
	Alto_Y = Alto_Total
	Radio_Y = Radio_Pral
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_I, Largo_Total = Largo_Y, Alto_Total = Alto_Y, Guia_X = True)
	
	
	Largo_Y += 1 + 1
	Alto_Y += 1 + 1
	Radio_Y += 1
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_I, Desfase = 1, Guia_X = True, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01')
	
	
	Largo_Y += 14 + 14
	Alto_Y += 14 + 14
	Radio_Y += 14
	
	# Actualizar_Lista01(Largo_X, Alto_X, Radio_X):
	Lista01 = Actualizar_Lista01(Largo_Y, Alto_Y, Radio_Y)
	# Crear_Contorno(Lista_X, Boceto_X, Simetria = False, Espejo = False, Largo_Total = -1, Alto_Total = -1, 
	# Desfase = -1, Guia_X = False, Grupo_Base = ['G_001', 'G_002'], Titulo_X = 'Margen_01'):
	Crear_Contorno(Lista01, Boceto_LVS_I, Desfase = 14, Guia_X = True, Grupo_Base = ['G_002', 'G_003'], Titulo_X = 'Grosor_01')
	
	
	# Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_X, Radio_Agujero = 1.5, 
	# Separacion = 76, Inicio_Centro = False, Incluir_Arco = False, Grupo_Base = ['', ''], Titulo_X = 'Radio'):
	Crear_Agujeros(Largo_Total, Alto_Total, Radio_Pral, Boceto_LVS_I, 7, 76, True, True, Grupo_Base = ['G_002', 'G_003'], Titulo_X = 'Iman')
	


#! Estas son las funciones para las partes que forman el Hoop
def Crear_Hoop(Largo_Total = '156 mm', Alto_Total = '156 mm', Radio_Pral = '35 mm'):
	
	# Validamos los argumentos de la funcion
	if not type(Largo_Total) in (float, int, str):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t {type(Largo_Total) = }')
	
	if not type(Alto_Total) in (float, int, str):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t {type(Alto_Total) = }')
		
	if not type(Radio_Pral) in (float, int, str):
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t {type(Radio_Pral) = }')
	
	# aqui convertimos el texto a numero con las unidades por defecto en FreeCAD
	try:
		LT = App.Units.Quantity(Largo_Total).Value
	except:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t (Largo_Total) = "{Largo_Total}"  ==>  {type(Largo_Total)}')
	
	try:
		AT = App.Units.Quantity(Alto_Total).Value
	except:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t (Alto_Total) = "{Alto_Total}"  ==>  {type(Alto_Total)}')
	try:
		RP = App.Units.Quantity(Radio_Pral).Value
	except:
		raise TypeError(f'\n\n\t Mensaje = No es Numero \n\t Funcion = Crear_Hoop \n\t (Radio_Pral) = "{Radio_Pral}"  ==>  {type(Radio_Pral)}')
	
	
	# Limpiar_Pantalla():
	Limpiar_Pantalla()
	
	# Crear_Contenedor_2D(LT, AT, RT):
	Crear_Contenedor_2D(LT, AT, RP)
	
	# Crear_Boceto_Cuerpo(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_Cuerpo(LT, AT, RP)
	
	# Crear_Boceto_Tapadera(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_Tapadera(LT, AT, RP)
	
	# Crear_Boceto_P1(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_P1(LT, AT, RP)
	
	# Crear_Boceto_P2(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_P2(LT, AT, RP)
	
	# Crear_Boceto_Iman(Largo_Total, Alto_Total, Radio_Pral):
	Crear_Boceto_Iman(LT, AT, RP)
	
	Seleccionar_Objeto(Boceto_LVS_I)
	
	
#! Variable Global
#$ Esta es la memoria de los Objetos 2D para revision y analisis
# Lista_Linea = [
#	ID objeto, ID punto inicial, ID punto final, nombre del Objeto, nombre del Contenedor, 
#	Longitud / Radio, Vector punto inicial, Vector punto final, Vector centro / NA, nombre del Grupo
# ]
Lista_Linea = []

# Lista_Restriccion = [
#	ID restriccion, ID objeto 1, ID punto inicial, ID objeto 2, ID punto final, Magnitud, nombre de la restriccion, nombre del Grupo
# ]
Lista_Restriccion = []


dias = ('Lun', 'Mar', 'Mie', 'Jue', 'Vie', 'Sab', 'Dom')

Ini = time.time()

#! Esta es la funcion que inicia la Macro
# Crear_Hoop(Largo_Total, Alto_Total, Radio_Pral):
Crear_Hoop('600 mm', '600 mm', '100 mm')

# '156 mm', '156 mm', '35 mm'
# '294 mm', '212 mm', '35 mm'
# '450 mm', '450 mm', '100 mm'






# Imprimir_Lista(Lista_X, Nom_Lista = 'Lista X'):
Imprimir_Lista(Lista_Linea, 'Lista_Linea')

# Imprimir_Lista(Lista_X, Nom_Lista = 'Lista X'):
Imprimir_Lista(Lista_Restriccion, 'Lista_Restriccion')





Fin = time.time()

indice = datetime.date.weekday(datetime.datetime.now())

print()

App.Console.PrintMessage(f'Fin de la {Pieza_H1.Label} en {round(Fin - Ini, 2)} seg\n')

print(f'{dias[indice]}  {time.strftime("%d/%m/%Y  %H:%M:%S", time.localtime())}')




'''
# Ejemplo mover la pieza usando una ventana flotante de PySide
	
	from PySide import QtGui
	val = QtGui.QInputDialog.getText(None, 'Mover Objeto', 'Ingrese los valores \n separados por coma. \n Ejemplo: 100,0,0')[0]
	myVal = tuple(val.split(','))
	Pieza_H1.Placement.Base = App.Vector(myVal)
	
'''




# Macro End: C:\Users\OWNER\AppData\Roaming\FreeCAD\Macro\Hoop_1.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
